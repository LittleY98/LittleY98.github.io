<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,个人博客,blog" />
  <meta name="description" content="LittleY的个人博客" />
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  
  
  <link rel="stylesheet" type="text/css" href="/./style/main.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>垃圾回收器</title>
  
  
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/">LittleY&#39;Blog</a>
  <a class="face-img" href="/">
    <img src="https://avatars.githubusercontent.com/u/47181393?v=4">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    垃圾回收器
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2021-05-22T06:42:30.000Z" itemprop="datePublished">2021-05-22</time>
      </li>
      <li>
        
    更新 <time datetime="2021-05-22T07:03:03.228Z" itemprop="dateUpdated">2021-05-22</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-常见的垃圾回收器"><a href="#1-常见的垃圾回收器" class="headerlink" title="1. 常见的垃圾回收器"></a>1. 常见的垃圾回收器</h3><p><strong>新生代收集器</strong>：</p>
<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ul>
<p><strong>老年代回收器</strong>：</p>
<ul>
<li>Serial Old</li>
<li>CMS</li>
<li>Parallel Old</li>
</ul>
<p><strong>堆内存垃圾收集器</strong>：</p>
<ul>
<li>G1</li>
</ul>
<p>他们之间的关系如下图：</p>
<img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200719180251166.png" alt="image-20200719180251166" style="zoom:67%;" />

<p>如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。</p>
<h3 id="2-新生代垃圾收集器"><a href="#2-新生代垃圾收集器" class="headerlink" title="2. 新生代垃圾收集器"></a>2. 新生代垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial 是一款用于新生代的单线程收集器，采用复制算法进行垃圾收集。Serial 进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World）。如图：</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720010811910.png" alt="image-20200720010811910"></p>
<p>当用户线程都执行到安全点时，所有线程暂停执行，Serial 收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行。</p>
<p><strong>优点</strong>：简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个cpu来说没有了上下文之间的的切换，效率比较高。</p>
<p><strong>缺点</strong>：会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。</p>
<p><strong>适用场景</strong>：Client 模式（桌面应用）；单核服务器。</p>
<p><strong>设置参数</strong>：可以用 -XX:+UserSerialGC 来选择 Serial 作为新生代收集器。</p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 就是一个 Serial 的多线程版本，其它与Serial并无区别。ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果，它默认开启的收集线程数和 CPU 数量一致，可以通过 -XX:ParallelGCThreads 来设置垃圾收集的线程数。如图：</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720011222477.png" alt="image-20200720011222477"></p>
<p><strong>优点</strong>：随着cpu的有效利用，对于GC时系统资源的有效利用有好处。</p>
<p><strong>适用场景</strong>：ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器。因为CMS收集器只能与serial或者parNew联合使用，在当下多核系统环境下，首选的是parNew与CMS配合。ParNew收集器也是使用CMS收集器后默认的新生代收集器。</p>
<p><strong>参数</strong>：可以用 -XX:UseParNewGC来选择新生代采用ParNew收集器  </p>
<blockquote>
<p>关于Parralel（并行）和Concurrent（并发）</p>
<p>Parralel（并行）：指多条垃圾收集线程并行工作、但此时用户线程仍然处于等待状态</p>
<p>Concurrent（并发）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，也可能是交替执行的），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</p>
</blockquote>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 也是一款用于新生代的多线程收集器，与 ParNew 的不同之处是ParNew 的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge 的目标是达到一个可控制的吞吐量。</p>
<p>例如虚拟机一共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那吞吐量就是 99% 。比如下面两个场景，垃圾收集器每 100 秒收集一次，每次停顿 10 秒，和垃圾收集器每 50 秒收集一次，每次停顿时间 7 秒，虽然后者每次停顿时间变短了，但是总体吞吐量变低了，CPU 总体利用率变低了。其与Parallel Old收集器运行示意图如下</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720010533117.png" alt="image-20200720010533117"></p>
<p><strong>适用场景</strong>：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互。</p>
<p><strong>参数</strong>：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小。</li>
</ul>
<h3 id="3-老年代垃圾收集器"><a href="#3-老年代垃圾收集器" class="headerlink" title="3. 老年代垃圾收集器"></a>3. 老年代垃圾收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old 收集器是 Serial 的老年代版本，同样是一个单线程收集器，采用标记-整理算法。如图：</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720011352198.png" alt="image-20200720011352198"></p>
<p><strong>适用场景</strong>：Client 模式（桌面应用）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案。</p>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>是Parallel Scavenge收集器的老年代版本。如图：</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720011413174.png" alt="image-20200720011413174"></p>
<p><strong>适用场景</strong>：与Parallel Scavenge 收集器搭配使用；注重吞吐量。</p>
<p><strong>参数</strong>：使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器。</p>
<h4 id="CMS-Concurrent-Mark-Sweep-收集器"><a href="#CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="CMS(Concurrent Mark Sweep) 收集器"></a>CMS(Concurrent Mark Sweep) 收集器</h4><p>CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤：</p>
<ol>
<li>初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快。</li>
<li>并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长。</li>
<li>重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短。</li>
<li>并发清除：用标记-清除算法清除垃圾对象，耗时较长。</li>
</ol>
<p>整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的。如图：</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720011436027.png" alt="image-20200720011436027"></p>
<p><strong>优点</strong>：</p>
<p>并发收集、低停顿</p>
<p><strong>缺点</strong>:</p>
<ol>
<li><p>对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小</p>
</li>
<li><p>无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。</p>
</li>
<li><p>因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC.</p>
</li>
</ol>
<p><strong>适用场景</strong>：重视服务器响应速度，要求系统停顿时间最短。</p>
<p><strong>参数</strong>：可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器</p>
<h3 id="4-新生代和老年代垃圾收集器"><a href="#4-新生代和老年代垃圾收集器" class="headerlink" title="4. 新生代和老年代垃圾收集器"></a>4. 新生代和老年代垃圾收集器</h3><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>一款面向服务端应用的垃圾收集器。G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region，如下图：</p>
<img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720011510478.png" alt="image-20200720011510478" style="zoom:67%;" />

<p>每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M。</p>
<p>为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。</p>
<p>G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。</p>
<p>如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似：</p>
<p><img src="https://gitee.com/littley98/My_Images/raw/master/Spring_Theory/image-20200720011534749.png" alt="image-20200720011534749"></p>
<p><strong>步骤</strong>：</p>
<ol>
<li><strong>初始标记</strong>：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。</li>
<li><strong>并发标记</strong>：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。</li>
<li><strong>最终标记</strong>：修正在并发标记阶段引用户程序执行而产生变动的标记记录。</li>
<li><strong>筛选回收</strong>：筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。</li>
</ol>
<p><strong>适用场景</strong>：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器。</p>

      </div>
        <div class="support-author">
          <p>感谢您的阅读。 🙏
          <a href="https://littley98.github.io/index.html" target="_blank">关于转载请看这里</a>
            <!--<a class="btn-pay"  href="#pay-modal">¥ 打赏支持</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          

        </div>
      </div>
    </div>
   </div>
</main>
<div class="footer">
  <div class="info">
    <p>
    <a target="_blank" rel="noopener" href="https://hexo.io"> Hexo </a> 强力驱动 |
      <a target="_blank" rel="noopener" href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      主题
    </p>
    <p>&copy;2020-2021 LittleY的博客</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\n欢迎访问 https://littley98.github.io/ ，围观LittleY的博客(づ｡◕‿‿◕｡)づ！\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
</body>
</html>
