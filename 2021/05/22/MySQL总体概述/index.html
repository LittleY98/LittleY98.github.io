<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,个人博客,blog" />
  <meta name="description" content="LittleY的个人博客" />
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  
  
  <link rel="stylesheet" type="text/css" href="/./style/main.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>MySQL总体概述</title>
  
  
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/">LittleY&#39;Blog</a>
  <a class="face-img" href="/">
    <img src="https://avatars.githubusercontent.com/u/47181393?v=4">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    MySQL总体概述
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2021-05-22T07:38:35.000Z" itemprop="datePublished">2021-05-22</time>
      </li>
      <li>
        
    更新 <time datetime="2021-05-22T07:40:17.762Z" itemprop="dateUpdated">2021-05-22</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <h2 id="MySQL架构方面"><a href="#MySQL架构方面" class="headerlink" title="MySQL架构方面"></a>MySQL架构方面</h2><h3 id="Mysql的基本架构图"><a href="#Mysql的基本架构图" class="headerlink" title="Mysql的基本架构图"></a>Mysql的基本架构图</h3><img src="https://gitee.com/LittleY98/My_Images/raw/master/Spring_Theory/image-20200724182426368.png" alt="image-20200724182426368" style="zoom:80%;" />

<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><ol>
<li>连接器负责跟客户端建立连接，获取权限、维持和管理连接<ul>
<li>用户名密码验证</li>
<li>查询权限信息，分配对应的权限</li>
<li>可以使用show processlist查看现在的连接</li>
<li>如果太长时间没有动静，就会自动断开，通过wait_timeout控制，默认8小时</li>
</ul>
</li>
<li>连接可以分为两类：<ul>
<li>长连接：推荐使用，但是要周期性的断开长连接</li>
<li>短链接：</li>
</ul>
</li>
</ol>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>当执行查询语句的时候，会先去查询缓存中查看结果，之前执行过的sql语句及其结果可能以key-value的形式存储在缓存中，如果能找到则直接返回，如果找不到，就继续执行后续的阶段。</p>
<p>但是，不推荐使用查询缓存：</p>
<ol>
<li>查询缓存的失效比较频繁，只要表更新，缓存就会清空</li>
<li>缓存对应新更新的数据命中率比较低</li>
</ol>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><ol>
<li><p>词法分析：Mysql需要把输入的字符串进行识别每个部分代表什<br>么意思</p>
<ul>
<li>把字符串 T 识别成 表名 T</li>
<li>把字符串 ID 识别成 列ID</li>
</ul>
</li>
<li><p>语法分析：</p>
<p>根据语法规则判断这个sql语句是否满足mysql的语法，如果不符合就会报错“You have an error in your SQL synta”</p>
</li>
</ol>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><ol>
<li>在具体执行SQL语句之前，要先经过优化器的处理<ul>
<li>当表中有多个索引的时候，决定用哪个索引</li>
<li>当sql语句需要做多表关联的时候，决定表的连接顺序</li>
<li>等等</li>
</ul>
</li>
<li>不同的执行方式对SQL语句的执行效率影响很大<ul>
<li>RBO:基于规则的优化</li>
<li>CBO:基于成本的优化</li>
</ul>
</li>
</ol>
<h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>RedoLog为innodb存储引擎的日志文件</p>
<ul>
<li>当发生数据修改的时候，innodb引擎会先将记录写到redo log中，并更新内存，此时更新就算是完成了，同时innodb引擎会在合适的时机将记录操作到磁盘中</li>
<li>Redolog是固定大小的，是循环写的过程</li>
<li>有了redolog之后，innodb就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做crash-safe</li>
</ul>
<p><strong>FAQ</strong>：既然要避免io，为什么写redo log的时候不会造成io的问题？</p>
<p><img src="https://gitee.com/LittleY98/My_Images/raw/master/Spring_Theory/image-20200724183439502.png" alt="image-20200724183439502"></p>
<h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><ul>
<li>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)</li>
<li>在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态</li>
<li>注意：undo log是逻辑日志，可以理解为：<ol>
<li>当delete一条记录时，undo log中会记录一条对应的insert记录</li>
<li>当insert一条记录时，undo log中会记录一条对应的delete记录</li>
<li>当update一条记录时，它记录一条对应相反的update记录</li>
</ol>
</li>
</ul>
<h3 id="Bin-log"><a href="#Bin-log" class="headerlink" title="Bin log"></a>Bin log</h3><p>binlog为服务端的日志文件</p>
<ul>
<li><p>Binlog是server层的日志，主要做mysql功能层面的事情</p>
</li>
<li><p>与redo日志的区别:</p>
<ol>
<li>redo是innodb独有的，binlog是所有引擎都可以使用的</li>
<li>redo是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是这个语句的原始逻辑</li>
<li>redo是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前的日志信息</li>
</ol>
</li>
<li><p>Binlog中会记录所有的逻辑，并且采用追加写的方式</p>
</li>
<li><p>一般在企业中数据库会有备份系统，可以定期执行备份，备份的周期可以自己设置</p>
</li>
<li><p>恢复数据的过程：</p>
<ol>
<li>找到最近一次的全量备份数据</li>
<li>从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时<br>刻</li>
</ol>
</li>
</ul>
<h3 id="数据更新的流程"><a href="#数据更新的流程" class="headerlink" title="数据更新的流程"></a>数据更新的流程</h3><p>执行流程：</p>
<ol>
<li>执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回</li>
<li>执行器拿到数据之后会先修改数据，然后调用引擎接口重新吸入数据</li>
<li>引擎将数据更新到内存，同时写数据到redo中，此时处于prepare阶段，并通知执行器执行完成，随时可以操作</li>
<li>执行器生成这个操作的binlog</li>
<li>执行器调用引擎的事务提交接口，引擎把刚刚写完的redo改成commit状态，更新完成</li>
</ol>
<p><strong>FAQ</strong>：为什么不先写binlog再写Redo Log？</p>
<ul>
<li><p><strong>先写redo log后写binlog:</strong></p>
<p>假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p>
</li>
<li><p><strong>先写binlog后写redo log:</strong></p>
<p>如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p>
</li>
</ul>

      </div>
        <div class="support-author">
          <p>感谢您的阅读。 🙏
          <a href="" target="_blank">关于转载请看这里</a>
            <!--<a class="btn-pay"  href="#pay-modal">¥ 打赏支持</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          

        </div>
      </div>
    </div>
   </div>
</main>
<div class="footer">
  <div class="info">
    <p>
    <a target="_blank" rel="noopener" href="https://hexo.io"> Hexo </a> 强力驱动 |
      <a target="_blank" rel="noopener" href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      主题
    </p>
    <p>&copy;2020-2021 LittleY的博客</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\n欢迎访问 https://littley98.github.io/ ，围观LittleY的博客(づ｡◕‿‿◕｡)づ！\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
</body>
</html>
