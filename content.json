{"meta":{"title":"LittleY'Blog","subtitle":"","description":"","author":"LittleY","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"垃圾回收算法","slug":"垃圾回收算法","date":"2021-05-22T07:06:28.000Z","updated":"2021-05-22T07:07:19.024Z","comments":true,"path":"2021/05/22/垃圾回收算法/","link":"","permalink":"http://example.com/2021/05/22/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","excerpt":"","text":"垃圾回收算算法1. Mark-Sweep（标记-清除算法）首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 缺点：标记和清除过程的效率都不高;还容易产生大量不连续的内存碎片 步骤图示： 2. Coping（复制算法）内存按容量划分为大小相等的两块，一块内存用完了,将存活着的对象复制到另外一块将都是垃圾对象的那块清空内存。 优点：速度贼快，无空间碎片 缺点：在对象存活率较高时，复制操作次数多，效率降低；內存缩小了一半;需要額外空间做分配担保(老年代) 步骤图示： 3. Mark-Compact（标记-整理法）标记步骤和标记清除算法相同，标记完后垃圾对象移动到一端,然后在清理掉。 缺点：很明显，效率很低 步骤图示： 4. Generational Collection（分代收集算法）根据以上三种方法可知，每种都有自己的有点和缺点。因此没有最好的算法，只有最合适的算法，因此我们在朝生夕死的新生代，使用效率较高的Coping算法，在CG不是特别频繁，且需要用来做Handle Promotion（空间担保）的老年区使用Mark-Compact算法或者Mark-Sweep算法。","categories":[],"tags":[]},{"title":"策略模式(Stratagy)","slug":"策略模式","date":"2021-05-22T06:45:30.000Z","updated":"2021-05-22T06:54:18.720Z","comments":true,"path":"2021/05/22/策略模式/","link":"","permalink":"http://example.com/2021/05/22/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式(Stratagy)定义策略模式 定义一系列算法，把他们独立封装起来，并且这些算法之间可以相互替换。策略模式主要是管理一堆有共性的算法，策略模式让算法独立于使用它的客户而变化，客户端可以根据需要，很快切换这些算法，并且保持可扩展性。 比如说，我有一个排序方法，但是这个排序的规则有好几种，比如说，针对一个实体类的id进行排序，也可以针对实体类的age进行排序等等还多中规则，这些规则我都是可以随时替换的。而策略模式就是来处理这一类问题。 优缺点优点： 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点： ​ 策略模式造成很多的策略类。 原理策略模式的原理图如下： Strategy类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法。 Concrete Strategy类：实现了抽象策略定义的接口，也就是真正干活的类 Context类：持有一个策略类的引用，最终给客户端调用 注意：Context也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 举个例子此时要开发一款软件，可以使用Java，也可以使用PHP，这两个语言属于两个策略。现在使用策略模式来实现这个问题。 抽象语言类 123public interface CodeLanguage &#123; void useLanguage();&#125; 具体语言类 123456public class CodeJava implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(&quot;使用Java语言编程&quot;); &#125;&#125; 123456public class CodePhp implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(&quot;使用Php语言编程&quot;); &#125;&#125; 策略引用类 1234567891011public class CodeContext &#123; CodeLanguage codeLanguage; public CodeContext1(CodeLanguage codeLanguage) &#123; this.codeLanguage = codeLanguage; &#125; void useLanguage()&#123; codeLanguage.useLanguage(); &#125;&#125; 使用模式 123456789public class Application &#123; public static void main(String[] args) &#123; CodeContext context; context = new CodeContext(new CodeJava()); context.useLanguage(); context = new CodeContext(new CodePhp()); context.useLanguage(); &#125;&#125; 此时，这个模型就已经用代码表示出来了，此时我们也不难发现，如果现在需要再增加一种策略的话，只需要新建一个CodeLanguage的实现类就可以了，在使用的时候可以直接调用策略。体现了它的扩展性","categories":[],"tags":[]},{"title":"动态代理（Dynamic Proxy）","slug":"动态代理","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:47:50.200Z","comments":true,"path":"2021/05/22/动态代理/","link":"","permalink":"http://example.com/2021/05/22/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"动态代理（Dynamic Proxy）1.定义原理和静态代理相同，只是为了解决静态代理的缺点。详情请点静态代理 2. 优缺点优点除了静态代理的优点外，还解决了静态代理的短板，可以动态生成代理类，大大减少了代码量。 缺点由于用的是反射的原理，性能相对较低。 3. 步骤角色： 接口类 实现类：被代理的类 代理类：必须实现InvocationHandler接口 4. 代码为了更加形象地理解JDK动态代理的使用流程，举个栗子。 今天，小黑要和王美丽去相亲，但是由于王美丽和小黑是第一次见面，小黑不好意思直接去找她的家人邀请她去约会和看电影。先看代码： Girl接口和王美丽的实体类： 12345678910111213package com.yang.proxy.demo2;/** * @program: Girl * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:47 */public interface Girl &#123; public void date(); public void watchMovie();&#125; 12345678910111213141516171819package com.yang.proxy.demo2;/** * @program: WangMeiLi * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:46 */public class WangMeiLi implements Girl &#123; public void date() &#123; System.out.println(&quot;王美丽：长得好看就行&quot;); &#125; public void watchMovie() &#123; System.out.println(&quot;王美丽：和你看电影很开心&quot;); &#125;&#125; 代理类： 123456789101112131415161718192021222324252627282930313233343536373839package com.yang.proxy.demo2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @program: MyProxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:55 */public class MyProxy implements InvocationHandler &#123; private Object target; public MyProxy(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Dad(); Object invoke = method.invoke(target, args); Mom(); return invoke; &#125; public Object getInstance()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; public void Dad()&#123; System.out.println(&quot;对你好不好?&quot;); &#125; public void Mom()&#123; System.out.println(&quot;有房吗？有车吗？&quot;); &#125;&#125; 小黑通过王美丽的家人去约她，王美丽的动作很单纯，值管看电影和看人家小黑好不好看。但是她的家人（代理类）可不放心，她的家人还要在invoke()方法里进行方法增强，比图说，她爸爸要看小黑对她好不好，她妈妈要看小黑有没有房和车。增强后才放心地用getInstance()方法让女儿去和小黑约会。 现在使用测试类进行测试： 123456789101112131415161718192021package com.yang.proxy.demo2;/** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */public class Demo &#123; public static void main(String[] args) &#123; WangMeiLi wangMeiLi = new WangMeiLi(); XiaoHei xiaoHei = new XiaoHei(); MyProxy families = new MyProxy(wangMeiLi); Girl wmother = (Girl) families.getInstance(); wmother.date(); wmother.watchMovie(); &#125;&#125; 结果如下： 对你好不好?王美丽：长得好看就行有房吗？有车吗？对你好不好?王美丽：和你看电影很开心有房吗？有车吗？ 此时，基础的代理功能已经达到了，但是还没有测试动态这个特点。因此我们现在创建一个Boy接口和小黑的类。 123456package com.yang.proxy.demo2;public interface Boy &#123; public void date(); public void watchMovie();&#125; 123456789101112131415161718package com.yang.proxy.demo2;/** * @program: XiaoHei * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 20:39 */public class XiaoHei implements Boy &#123; public void date() &#123; System.out.println(&quot;好看就行&quot;); &#125; public void watchMovie() &#123; System.out.println(&quot;电影不好看&quot;); &#125;&#125; 现在我们没有为小黑做任何的代理类，现在我们用这个动态代理类进行测试： 1234567891011121314151617181920package com.yang.proxy.demo2;/** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */public class Demo &#123; public static void main(String[] args) &#123; XiaoHei xiaoHei = new XiaoHei(); MyProxy heiFamilies = new MyProxy(xiaoHei); Boy hMother = (Boy) heiFamilies.getInstance(); hMother.date(); hMother.watchMovie(); &#125;&#125; 结果如下： 对你好不好?小黑:好看就行有房吗？有车吗？对你好不好?小黑:电影不好看有房吗？有车吗？ 可见，测试成功！","categories":[],"tags":[]},{"title":"单例模式(Singleton Pattern)","slug":"单例模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:50:14.700Z","comments":true,"path":"2021/05/22/单例模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式在有些开发场景中，没有必要有多个实例存在，以节省资源。比如说 PropertiyMgr 工具类 饿汉式实现代码如下： 12345678910111213141516171819public class Mgr01 &#123; private static final Mgr01 INSTANCE = new Mgr01(); private Mgr01() &#123;&#125;; public static Mgr01 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr01 m1 = Mgr01.getInstance(); Mgr01 m2 = Mgr01.getInstance(); System.out.println(m1 == m2); &#125;&#125; 还有一种写法，和上面的写法效果一模一样： 12345678910111213141516171819202122public class Mgr02 &#123; private static final Mgr02 INSTANCE; static &#123; INSTANCE = new Mgr02(); &#125; private Mgr02() &#123;&#125;; public static Mgr02 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr02 m1 = Mgr02.getInstance(); Mgr02 m2 = Mgr02.getInstance(); System.out.println(m1 == m2); &#125;&#125; 优点：类加载到内存后，就实例化一个单例，JVM 保证线程安全简单实用，推荐使用！ 缺点：不管用到与否，类装载时就完成实例化。如果用不上它的话，装载它会造成资源浪费。 由此我们有了另一个解决方案，那就是懒汉式： 懒汉式（Lazy Loading）第一种写法实现代码如下： 12345678910111213141516171819202122public class Mgr03 &#123; private static Mgr03 INSTANCE; private Mgr03() &#123; &#125; public static Mgr03 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr03(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 由上面代码可知，使用懒汉式之后，达到了按需初始化的目的。但是随之而来的是更严重的问题，那就是它的线程不安全问题。 就是说，两个线程如果接近同时进入 INSTANCE == null 的判断语句时，两个都会进入里面的代码块进行new对象。可知此时两个线程拿到的实例就不是同一个实例。这就是线程不安全问题。可以用以下测试代码对其进行测试： 1234567public static void main(String[] args) &#123; for(int i=0; i&lt;100; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Mgr04.getInstance().hashCode()); &#125;).start(); &#125;&#125; 为了解决线程不安全的问题，我们又进行了以下优化： 第二种写法代码如下： 12345678910111213141516171819202122public class Mgr04 &#123; private static Mgr04 INSTANCE; private Mgr04() &#123; &#125; public static synchronized Mgr04 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr04(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 我们对实例方法进行了加锁处理，保证了线程安全的问题。但是，不难想象，如果有大量的线程访问的话，那么它的效率会大幅下降。 我们再做一下优化： 123456789101112131415161718192021222324public class Mgr05 &#123; private static Mgr05 INSTANCE; private Mgr05() &#123; &#125; public static Mgr05 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Mgr05.class) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr05(); &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次我们把锁加在了实例方法里面的Mgr05.class上，妄图通过减小同步代码块的方式提高效率，测试后，不可行。 原因是，虽然对Mgr05.class进行了加锁，但是如果两个线程同时进入INSTANCE==null代码块里面，它依然会new出两个不同的实例。 现在可知，问题就处在了INSTANCE == null判断语句这块儿，那么我们针对这块儿进行优化。 第三种写法123456789101112131415161718192021222324252627public class Mgr06 &#123; private static Mgr06 INSTANCE; //JIT private Mgr06() &#123; &#125; public static Mgr06 getInstance() &#123; if (INSTANCE == null) &#123; //双重检查 synchronized (Mgr06.class) &#123; if(INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr06(); &#125; &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次优化，我们针对的就是判断实例是否为空这个点，进行了双层检查，即使两个同时进入了第一层判断，一个拿到锁之后，先实例化了一个对象，第二个再进去之后，还需要第二只判断，如果已经有了实例，那么就直接跳出，不再new新的实例。 这时可能会有个疑问，那么外层的检查还有必要存在吗？答案是当然需要，如果没有了外层的判断，每个线程都要加锁上锁，不得把JVM累死，下可能自然就变差了。 静态内部类方式代码如下： 12345678910111213141516public class Mgr07 &#123; private Mgr07() &#123; &#125; private volatile static class Mgr07Holder &#123; private final static Mgr07 INSTANCE = new Mgr07(); &#125; public static Mgr07 getInstance() &#123; return Mgr07Holder.INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这个方法算是目前来说比较完美的一种写法。JVM保证单例，加载外部类时不会加载内部类，这样可以即可以实现懒加载，还能保证线程安全。 注意使用volatile修饰单例对象，目的是保证多线程环境下的线程安全。 枚举类方法代码如下： 1public enum Mgr08 &#123; INSTANCE; public void m() &#123;&#125;&#125; 这是《Java Effective》这本书中的一种写法，写法简单，还能保证线程同步问题，还可以防止反序列化(通俗点说就是防止反射对其造成的破坏)。中功能上来说是所有单例模式写法中最完美的。但是个人不推荐这种写法，比较别扭，不够优雅。 设计模式是一种生产技巧和模式，没有必要像孔乙己一样研究茴字有几种写法，以实际开发的场景的选择不同的写法。","categories":[],"tags":[]},{"title":"工厂模式（Factory Pattern）","slug":"工厂模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:55:04.855Z","comments":true,"path":"2021/05/22/工厂模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式工厂设计模式，就是用来生产对象的，在Java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则，如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦 一共有3中工厂设计模式：简单工厂、工厂方法、抽象工厂 简单工厂设计模式一个工厂方法，依据传入的参数，生成对应的产品对象。 共有3个角色：抽象产品、局具体产品、具体工厂 代码实现水果接口： 123public interface Fruit &#123; void whatIm();&#125; 具体类： 123456public class Apple implements Fruit &#123; @Override public void whatIm() &#123; //苹果 &#125;&#125; 123456public class Pear implements Fruit &#123; @Override public void whatIm() &#123; //梨 &#125;&#125; 具体工厂： 123456789101112public class FruitFactory &#123; public Fruit createFruit(String type) &#123; if (type.equals(&quot;apple&quot;)) &#123;//生产苹果 return new Apple(); &#125; else if (type.equals(&quot;pear&quot;)) &#123;//生产梨 return new Pear(); &#125; return null; &#125;&#125; 使用产品： 123FruitFactory mFactory = new FruitFactory();Apple apple = (Apple) mFactory.createFruit(&quot;apple&quot;);//获得苹果Pear pear = (Pear) mFactory.createFruit(&quot;pear&quot;);//获得梨 缺点这个设计模式的缺点显而易见，当我需要添加一种水果的时候，我不但需要新建一个水果的类，还需要修改工厂类。违反了开闭原则。因此，它只使用于产品数较少，产品变化的需求较少的场景。 工厂方法设计模式将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定。 共有4个角色：抽象产品类、具体产品类、抽象工厂类、具体工厂类 代码实现工厂接口： 123public interface FruitFactory &#123; Fruit createFruit();//生产水果&#125; 苹果工厂： 123456public class AppleFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Apple(); &#125;&#125; 梨工厂： 123456public class PearFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Pear(); &#125;&#125; 使用： 1234AppleFactory appleFactory = new AppleFactory();PearFactory pearFactory = new PearFactory();Apple apple = (Apple) appleFactory.createFruit();//获得苹果Pear pear = (Pear) pearFactory.createFruit();//获得梨 缺点这种方式，虽然解耦成功，也遵循了开闭原则，但是最根本的问题依然存在，如果需要增加水果的话，还得创建大量的工厂类，很麻烦。 抽象工厂设计模式为创建一组相关或者是相互依赖的产品族提供的一个接口，而不需要指定它们的具体类。 代码实现cpu接口和实现类： 1234567891011121314151617public interface Cpu &#123; void run(); class Cpu650 implements Cpu &#123; @Override public void run() &#123; //625 也厉害 &#125; &#125; class Cpu825 implements Cpu &#123; @Override public void run() &#123; //825 处理更强劲 &#125; &#125;&#125; 屏幕和接口实现类： 1234567891011121314151617181920public interface Screen &#123; void size(); class Screen5 implements Screen &#123; @Override public void size() &#123; //5寸 &#125; &#125; class Screen6 implements Screen &#123; @Override public void size() &#123; //6寸 &#125; &#125;&#125; 工厂接口： 123456public interface PhoneFactory &#123; Cpu getCpu();//使用的cpu Screen getScreen();//使用的屏幕&#125; 实现： 123456789101112public class HongMiFactory implements PhoneFactory &#123; @Override public Cpu getCpu() &#123; return new Cpu.Cpu650();//高效处理器 &#125; @Override public Screen getScreen() &#123; return new Screen.Screen5();//小屏手机 &#125;&#125; 以上例子可以看出，抽象工厂可以解决一系列的产品生产的需求，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展； 总结 对于简单工厂和工厂方法来说，两者的使用方式实际是一样的，对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式。毕竟效果都一样，何必要用一个写起来更麻烦的方法呢。 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产。","categories":[],"tags":[]},{"title":"建造者模式（Builder Patttern）","slug":"建造者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:53:41.025Z","comments":true,"path":"2021/05/22/建造者模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式（Builder Patttern）在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。这时就需要建造者模式来解决。 1. 定义指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 2. 优缺点优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 3. 原理主要角色 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：也叫导演类，它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 结构图 实现步骤 创建抽象建造者定义造房步骤 创建工人具体实现造房步骤 创建承包商指挥工人施工 验收，检查是否建造完成 4. 代码实现产品类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.yang.builder;/** * @program: Product * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:41 */public class Product &#123; private String buildA; private String buildB; private String buildC; private String buildD; public String getBuildA() &#123; return buildA; &#125; public void setBuildA(String buildA) &#123; this.buildA = buildA; &#125; public String getBuildB() &#123; return buildB; &#125; public void setBuildB(String buildB) &#123; this.buildB = buildB; &#125; public String getBuildC() &#123; return buildC; &#125; public void setBuildC(String buildC) &#123; this.buildC = buildC; &#125; public String getBuildD() &#123; return buildD; &#125; public void setBuildD(String buildD) &#123; this.buildD = buildD; &#125; @Override public String toString() &#123; return &quot;Product&#123;&quot; + &quot;buildA=&#x27;&quot; + buildA + &#x27;\\&#x27;&#x27; + &quot;, buildB=&#x27;&quot; + buildB + &#x27;\\&#x27;&#x27; + &quot;, buildC=&#x27;&quot; + buildC + &#x27;\\&#x27;&#x27; + &quot;, buildD=&#x27;&quot; + buildD + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 建造类123456789101112131415161718package com.yang.builder;/** * @program: Build * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:43 */public abstract class Build &#123; public abstract Build setBuildA(); public abstract Build setBuildB(); public abstract Build setBuildC(); public abstract Build setBuildD(); public abstract Product getProduct();&#125; 具体建造者类1234567891011121314151617181920212223242526272829303132333435363738394041package com.yang.builder;/** * @program: Worker * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:45 */public class Worker extends Build &#123; private Product product; public Worker() &#123; product = new Product(); &#125; public Build setBuildA() &#123; product.setBuildA(&quot;地基&quot;); return this; &#125; public Build setBuildB() &#123; product.setBuildB(&quot;钢金&quot;); return this; &#125; public Build setBuildC() &#123; product.setBuildC(&quot;水电&quot;); return this; &#125; public Build setBuildD() &#123; product.setBuildD(&quot;粉刷&quot;); return this; &#125; public Product getProduct() &#123; return product; &#125;&#125; 导演类1234567891011121314151617package com.yang.builder;/** * @program: Derict * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:48 */public class Derict &#123; public Product create(Build build)&#123; build.setBuildA().setBuildB().setBuildC().setBuildD(); return build.getProduct(); &#125;&#125; 客户类1234567891011121314151617package com.yang.builder;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:50 */public class MyDemo &#123; public static void main(String[] args) &#123; Derict derict = new Derict(); Product product = derict.create(new Worker()); System.out.println(product); &#125;&#125;","categories":[],"tags":[]},{"title":"模板模式（Template Pattern）","slug":"模板模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:54:05.920Z","comments":true,"path":"2021/05/22/模板模式/","link":"","permalink":"http://example.com/2021/05/22/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板模式（Template Pattern）完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。这就是模板模式。 1. 定义定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 2. 优缺点优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 3. 原理角色 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中申明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 结构图 4. 代码实现老规矩，举个栗子。迎接客人，而这个迎接客人的流程是一样的，都是visit、talk、bye。但是根据客人身份的不同，实现的方式也不同，这里设定的是两种客人，一种是儿子带女朋友回家，一个是女儿带男朋友回家。 抽象类： 123456789101112131415161718192021/** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */public abstract class Welcome &#123; public abstract void visit(); public abstract void talk(); public abstract void bye(); public void run()&#123; visit(); talk(); bye(); &#125;&#125; 迎接儿子女朋友的实现类： 12345678910111213141516171819202122package com.yang.template;/** * @program: LoverOfSon * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:51 */public class LoverOfSon extends Welcome &#123; public void visit() &#123; System.out.println(&quot;来就来嘛还带这么多东西&quot;); &#125; public void talk() &#123; System.out.println(&quot;这姑娘真不错&quot;); &#125; public void bye() &#123; System.out.println(&quot;20w彩礼，你看看够不够，不够我们再加&quot;); &#125;&#125; 迎接女儿男朋友的实现类： 12345678910111213141516171819202122package com.yang.template;/** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(&quot;除了华子，送别的烟我不抽，拉嗓子&quot;); &#125; public void talk() &#123; System.out.println(&quot;有车吗？有房吗？有什么学位？&quot;); &#125; public void bye() &#123; System.out.println(&quot;没50w彩礼别想娶我家姑娘&quot;); &#125;&#125; 测试类： 1234567891011121314151617181920package com.yang.template;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:56 */public class MyDemo &#123; public static void main(String[] args) &#123; Welcome loverOfSon = new LoverOfSon(); loverOfSon.run(); System.out.println(); Welcome loverOfDaughter = new LoverOfDaughter(); loverOfDaughter.run(); &#125;&#125; 运行结果 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？没50w彩礼别想娶我家姑娘 可见这个模式已经实现。但是此时还有一个新问题，如果说客人来了，还得吃饭，老头还得喝点。那么就需要在Welcome流程里加一个喝酒类，但是也不行，如果是儿子带女朋友回来的话，让人一姑娘喝酒也不合适。这时我们要解决的问题就是，通过子类的操作来实现，对父类流程的调控。因此我们用了一个钩子方法来解决这个问题。下面我们对上面的代码进行改造。 Welcaome类： 1234567891011121314151617181920212223242526272829303132package com.yang.template;/** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */public abstract class Welcome &#123; protected boolean isDrink()&#123; return false; &#125; protected abstract void visit(); protected abstract void talk(); protected abstract void bye(); protected void Drink()&#123; System.out.println(&quot;哈啤酒~~~&quot;); &#125; public void run()&#123; visit(); talk(); if (isDrink())&#123; Drink(); &#125; bye(); &#125;&#125; LoverOfDaughter类： 1234567891011121314151617181920212223242526272829303132package com.yang.template;/** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(&quot;除了华子，送别的烟我不抽，拉嗓子&quot;); &#125; public void talk() &#123; System.out.println(&quot;有车吗？有房吗？有什么学位？&quot;); &#125; @Override protected boolean isDrink() &#123; return true; &#125; @Override protected void Drink() &#123; System.out.println(&quot;喝白的&quot;); &#125; public void bye() &#123; System.out.println(&quot;没50w彩礼别想娶我家姑娘&quot;); &#125;&#125; 其他类保持原样，运行之后的效果如下： 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？喝白的没50w彩礼别想娶我家姑娘 我们以上的问题已经解决，在这次改进中，我给isDrick()方法了初始值，就是不喝，也给了Drink()方法了初始值。这样子类就可以根据需要进行选择重写或者不重写。 这就是我们的模板模式，看完之后可能第一感觉就是，非常熟悉。是的，我们的编码过程中，经常使用，但是不知道它的名字而已。设计模式仅仅是一个设计过程中的技巧和模式。在实际开发中，知不知道他的名字无所谓，到了使用的时候，自然就用出来了。这就是传说中的，无招胜有招。","categories":[],"tags":[]},{"title":"观察者模式（Observer Pattern）","slug":"观察者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:53:30.230Z","comments":true,"path":"2021/05/22/观察者模式/","link":"","permalink":"http://example.com/2021/05/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式（Observer Pattern）在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。 1. 定义指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 2. 优缺点优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 3. 实现角色 抽象对象（IObject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体对象（Concrete Object）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 模式图 4. 代码抽象对象类： 123456789101112131415161718192021222324252627282930package com.yang.observe;import java.util.ArrayList;import java.util.List;/** * @program: IObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:02 */public abstract class IObject &#123; protected List&lt;IObserver&gt; list=new ArrayList&lt;IObserver&gt;(); //增加观察者方法 public void add(IObserver observer) &#123; list.add(observer); &#125; //删除观察者方法 public void remove(IObserver observer) &#123; list.remove(observer); &#125; //通知观察者方法 public abstract void notifyObserver();&#125; 具体对象类： 123456789101112131415161718package com.yang.observe;/** * @program: ConcreteObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:05 */public class ConcreteObject extends IObject &#123; public void notifyObserver() &#123; System.out.println(&quot;目标角色发生了变化&quot;); for (IObserver observer : super.list) &#123; observer.response(&quot;ConcreteObject发生变化&quot;); &#125; &#125;&#125; 观察者接口： 123456789101112package com.yang.observe;/** * @program: IObserver * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */public interface IObserver &#123; public void response(String msg);&#125; 具体观察者1 123456789101112131415package com.yang.observe;/** * @program: Observer * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */public class Observer1 implements IObserver&#123; public void response(String msg) &#123; System.out.println(&quot;Observer01知道了[&quot; + msg + &quot;]&quot; ); &#125;&#125; 具体观察者2： 123456789101112131415package com.yang.observe;/** * @program: Observer2 * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:10 */public class Observer2 implements IObserver&#123; public void response(String msg) &#123; System.out.println(&quot;Observer02知道了[&quot; + msg + &quot;]&quot; ); &#125;&#125; 测试类： 1234567891011121314151617181920package com.yang.observe;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:11 */public class MyDemo &#123; public static void main(String[] args) &#123; Observer1 observer1 = new Observer1(); Observer2 observer2 = new Observer2(); ConcreteObject concreteObject = new ConcreteObject(); concreteObject.add(observer1); concreteObject.add(observer2); concreteObject.notifyObserver(); &#125;&#125; 运行结果： 目标角色发生了变化Observer01知道了[ConcreteObject发生变化]Observer02知道了[ConcreteObject发生变化]","categories":[],"tags":[]},{"title":"静态代理模式（Static Proxy）","slug":"静态代理模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:53:50.822Z","comments":true,"path":"2021/05/22/静态代理模式/","link":"","permalink":"http://example.com/2021/05/22/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"静态代理模式（Static Proxy）1. 定义给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。防止直接访问目标对象给系统带来的不必要复杂性。 2. 优缺点优点 可以使真是角色的操作更加纯粹，不用去关心一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点 一个真是角色会产生一个代理角色，代码量翻倍，开发效率低！ 实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 3. 原理角色 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 结构图 实现步骤 创建抽象对象接口（Subject） 创建真实对象类（RealSubject） 创建代理对象类（Proxy） 客户端调用 4. 代码实现比如，现在我要租一个房子，但是我又不想自己去找房东，也不想自己去谈价钱，看房子这些破事儿，我就可以去找中介代理帮我做。 创建一个Rent接口12345package com.yang.proxy.demo1;public interface Rent &#123; public void rentRoom();&#125; 创建一个真实对象类1234567891011121314package com.yang.proxy.demo1;/** * @program: Client * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:52 */public class Client implements Rent &#123; public void rentRoom() &#123; System.out.println(&quot;我是客户，我要租房子&quot;); &#125;&#125; 创建代理对象类12345678910111213141516171819202122232425262728293031323334package com.yang.proxy.demo1;/** * @program: Proxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:53 */public class Proxy implements Rent &#123; private Client client; public Proxy() &#123; &#125; public Proxy(Client client) &#123; this.client = client; &#125; public void rentRoom() &#123; lookRoom(); client.rentRoom(); bargin(); &#125; public void bargin()&#123; System.out.println(&quot;我是中介，我在讲价&quot;); &#125; public void lookRoom()&#123; System.out.println(&quot;我是中介，我在看房&quot;); &#125;&#125; 调用12345678910111213141516package com.yang.proxy.demo1;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:54 */public class MyDemo &#123; public static void main(String[] args) &#123; Client client = new Client(); Proxy proxy = new Proxy(client); proxy.rentRoom(); &#125;&#125;","categories":[],"tags":[]},{"title":"垃圾回收器","slug":"垃圾回收器","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T07:03:03.228Z","comments":true,"path":"2021/05/22/垃圾回收器/","link":"","permalink":"http://example.com/2021/05/22/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","excerpt":"","text":"垃圾回收器1. 常见的垃圾回收器新生代收集器： Serial ParNew Parallel Scavenge 老年代回收器： Serial Old CMS Parallel Old 堆内存垃圾收集器： G1 他们之间的关系如下图： 如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。 2. 新生代垃圾收集器Serial 收集器Serial 是一款用于新生代的单线程收集器，采用复制算法进行垃圾收集。Serial 进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World）。如图： 当用户线程都执行到安全点时，所有线程暂停执行，Serial 收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行。 优点：简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个cpu来说没有了上下文之间的的切换，效率比较高。 缺点：会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。 适用场景：Client 模式（桌面应用）；单核服务器。 设置参数：可以用 -XX:+UserSerialGC 来选择 Serial 作为新生代收集器。 ParNew 收集器ParNew 就是一个 Serial 的多线程版本，其它与Serial并无区别。ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果，它默认开启的收集线程数和 CPU 数量一致，可以通过 -XX:ParallelGCThreads 来设置垃圾收集的线程数。如图： 优点：随着cpu的有效利用，对于GC时系统资源的有效利用有好处。 适用场景：ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器。因为CMS收集器只能与serial或者parNew联合使用，在当下多核系统环境下，首选的是parNew与CMS配合。ParNew收集器也是使用CMS收集器后默认的新生代收集器。 参数：可以用 -XX:UseParNewGC来选择新生代采用ParNew收集器 关于Parralel（并行）和Concurrent（并发） Parralel（并行）：指多条垃圾收集线程并行工作、但此时用户线程仍然处于等待状态 Concurrent（并发）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，也可能是交替执行的），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。 Parallel Scavenge 收集器Parallel Scavenge 也是一款用于新生代的多线程收集器，与 ParNew 的不同之处是ParNew 的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge 的目标是达到一个可控制的吞吐量。 例如虚拟机一共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那吞吐量就是 99% 。比如下面两个场景，垃圾收集器每 100 秒收集一次，每次停顿 10 秒，和垃圾收集器每 50 秒收集一次，每次停顿时间 7 秒，虽然后者每次停顿时间变短了，但是总体吞吐量变低了，CPU 总体利用率变低了。其与Parallel Old收集器运行示意图如下 适用场景：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互。 参数： XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间 XX:GCRatio 直接设置吞吐量的大小。 3. 老年代垃圾收集器Serial Old 收集器Serial Old 收集器是 Serial 的老年代版本，同样是一个单线程收集器，采用标记-整理算法。如图： 适用场景：Client 模式（桌面应用）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案。 Parallel Old 收集器是Parallel Scavenge收集器的老年代版本。如图： 适用场景：与Parallel Scavenge 收集器搭配使用；注重吞吐量。 参数：使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器。 CMS(Concurrent Mark Sweep) 收集器CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤： 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快。 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长。 重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短。 并发清除：用标记-清除算法清除垃圾对象，耗时较长。 整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的。如图： 优点： 并发收集、低停顿 缺点: 对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小 无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。 因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC. 适用场景：重视服务器响应速度，要求系统停顿时间最短。 参数：可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器 4. 新生代和老年代垃圾收集器G1 收集器一款面向服务端应用的垃圾收集器。G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region，如下图： 每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M。 为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。 G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。 如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似： 步骤： 初始标记：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。 并发标记：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。 最终标记：修正在并发标记阶段引用户程序执行而产生变动的标记记录。 筛选回收：筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。 适用场景：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器。","categories":[],"tags":[]},{"title":"对象的内存布局和创建","slug":"对象的内存布局和创建","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T07:01:07.729Z","comments":true,"path":"2021/05/22/对象的内存布局和创建/","link":"","permalink":"http://example.com/2021/05/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%88%9B%E5%BB%BA/","excerpt":"","text":"对象的内存布局和创建1. 对象的内存布局对象的内存布局分为3个区域：Header（对象头）、Instance Data（实例数据）、Padding（对齐填充） Header（对象头） 运行时的数据（Mark Word）：如HashCode（哈希码）、GC分代年龄、锁状态标志、线程持有的锁等等 类型指针：通过这个指针确定这个对象属于哪个类 Instance Data（实例数据）这部分是存储真正的有效信息，也就是在程序代码中所定义的各种类型的字段内容。 Padding（对齐填充）这部分信息没有任何意义，仅仅是为了使得对象占的内存大小为8字节的整数倍。 2. 对象的创建在语言层面，使用new关键字即可创建出一个对象。但是在虚拟机中，对象创建的创建过程则是比较复杂的。 (1) 首先，虚拟机运到new指令时，会去常量池检查是否存在new指令中包含的参数，比如new People(),则虚拟机首先会去常量池中检查是否有Student这个类的符号引用，并且检查这个类是否已经被加载了，如果没有则会执行类加载过程。 (2) 在类加载检查过后，接下来为对象分配内存当然是在java堆中分配。 (3) 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也许会提前值TLAB分配时进行。这一步保证了对象实例字段在Java中不赋值也可以直接使用。 (4) 接来下，虚拟机对对象进行必要的设置，例如这个对象属于哪个类的实例，如何找到类的元数据信息。对象的哈希吗、对象的GC年代等信息，这些信息都存放在对象头之中。 (5) 执行完上面工作之后，所有的字段都为0，接着执行指令，把对象按照程序员的指令进行初始化，这样一个对象就完整的创建出来。 这就完了吗？？？？当然没有！！请往下看！ 3. 对象空间的分配Java堆为对象分配内存的方式有两种：Bump the Pointer(指针碰撞)和Free List(空闲列表) **Bump the Pointer(指针碰撞)**：假设Java堆中的内存都放在一起，所有是使用过的内存放到一边，空闲的内存放到另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅把指针相空闲空间的方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞” **Free List(空闲列表)**：当使用内存和空闲内存交织在一起时，JVM需要维护一个列表，记录哪些内存是可用的，在给对象分配内存时从列表中找到一块足够大的内存空间划分给对象，并更新列表上的记录。这种分配方式称之为“空闲列表” Java Heap内存采用哪种分配方式取决于Java Heap内存是否带有空间压缩整理的能力决定。也就是说有垃圾回收器采用哪种回收算法来决定的。当垃圾回收器采用的是标记-清理算法，如CMS垃圾回收器，那么使用的就是空闲列表的分配方式。当使用Serial、parNew等带有压缩整理过程的收集器，采用的是指针碰撞的内存分配方式 4. 对象的访问对象的访问方式主流的有两种：句柄访问方式和直接指针访问方式 句柄访问方式在Java堆中划分一块内存来作为句柄池，句柄池中包含了对象数据和对象类型的具体地址信息。通过这些信息可以访问到对象实例数据和对象类型数据。Java栈中的reference存储对象的句柄池地址即可。如图： 直接指针访问方式reference中存储的就是对象地址。如图： 二者优势句柄访问方式的优势就是稳定，reference中存储的是稳定的句柄地址，在对象移动时只会改变句柄中实例数据的指针，而reference本身不被修改。 直接访问方式的优势就是速度快，节省了指针定位的时间开销 HotSpot虚拟机采用的是直接指针访问方式","categories":[],"tags":[]},{"title":"对象已死吗","slug":"对象已死吗","date":"2021-05-22T05:02:30.000Z","updated":"2021-05-22T07:02:03.431Z","comments":true,"path":"2021/05/22/对象已死吗/","link":"","permalink":"http://example.com/2021/05/22/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97/","excerpt":"","text":"对象已死吗？Java Heap中存放着几乎所有的对象实例，垃圾回收前，最重要的事就是判断是对象是否存活（还在被引用的对象）。 1. 引用计数法给对象添加一个引用计数器,每一个地方引用它,计数器值就加1，对象引用失效的时候,计数器就减1.计数器值为0的时候,此对象为垃圾。 优点：判定效率高 缺点:如果对象间循环依赖,此算法无法正确判断是否为垃圾对象。因此主流虚拟机都没有用这种算法。 循环依赖如下图所示： 2. 可达性分析算法目前主流的JVM都是用的可达性分析算法来判断对象是否存货的。 实现方法GC Roots的对象作为起始点从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain)当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达的。如下图： 图中黄色的对象仍然存活，灰色的显然是不可达的，即为可回收的对象。 可作为GC Root对象的包括 栈帧中本地变量表中引用的对象 方法区类静态属性引用的对象 方法区中常量引用的对象 方法栈JNI引用的对象 关于引用（强软弱虚）强引用：类似于Object obj = new Object()这种的就属于强引用，只要强引用存在，就永远不会被回收。 软引用：有用，但是非必须的对象。对于这些软引用关联的对象，在要发生内存异常前，将会把他们列到回收范围中进行GC，如果内存依然不够，才会报内存溢出异常。 弱引用：非必须对象，被若引用关联的对象只能生存到下一次GC发生之前。当开始GC时，无论内存是否够用，都会回收。 虚引用：最弱的一种引用关系，一个对象是否有虚引用，完全不影响其生存时间，，也无法通过虚引用来取得一个对象实例。为对象设置虚引用的唯一目的就是能在这个对象被回收时，收到一个系统通知。 3. 不可达对象是否死亡判断当对象不可达GC Roots时，将会对其进行第一次筛选，如果其未覆盖finalize()方法或者已经调用过一次finalize()方法的话，讲直接将其回收。否则，将会给其一个逃脱死亡命运的机会，并对其标记。如果到第二次GC时，它还没有被引用的话，那将会被直接回收。 4. Method Area的回收此区域的垃圾回收效率较低。 一般回收两部分内容，即：废弃常量和无用的类。 废弃常量：如果无任何地方引用此常量，那么它讲在下一次GC时被回收。 无用的类：需要同时达到以下三个条件: 该类所有实例都被回收 加载该类的ClassLoader被回收 该类对应的class对象没有被引用,无法在任何地方反射访问该类方法","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-22T04:48:48.914Z","updated":"2021-05-22T04:48:48.914Z","comments":true,"path":"2021/05/22/hello-world/","link":"","permalink":"http://example.com/2021/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}