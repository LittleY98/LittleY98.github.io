{"meta":{"title":"LittleY'Blog","subtitle":"","description":"","author":"LittleY","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Git命令集合","slug":"Git命令集合","date":"2021-05-22T07:23:00.000Z","updated":"2021-05-22T07:23:10.857Z","comments":true,"path":"2021/05/22/Git命令集合/","link":"","permalink":"http://example.com/2021/05/22/Git%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/","excerpt":"","text":"Git命令集合1. 提前配置12git config --global user.name USERNAME #配置用户名git config --global user.email USEREMAIL #配置用户邮箱 2. 提交步骤12345git init #初始化git仓库git status #查看文件状态git add #添加到缓存区，追踪文件git commit -m MESSAGE #提交信息，向仓库中提交代码git log #查看提交记录 3. Git撤销123git checkout FILENAME #用暂存区的文件覆盖工作目录中的文件git rm --cached FILENAME #将文件从暂存区删除git reset --hard COMMITID #将git仓库中指定的更新记录恢复出来，并覆盖暂存区和工作目录 4. Git分支1234567git branch #查看分支git branch 分支名称 #创建分支git checkout 分支名称 #切换分支git merge 来源分支 #合并分支git branch -d 分支名称 #删除分支（分支被合并后才允许被删除） （-D代表强制删除） 5. 暂时保存更改12git stash #存储临时改动git stash pop #恢复改动 6. 推送到远程仓库12345git push 远程仓库地址 分支名称 #将当前分支推送到远端仓库的指定点分支中git push 远程仓库地址别名 分支名称git push -u 远程仓库地址别名 分支名称 # -u是记住地址及分支，下次推送直接git push即可git remote add 远程仓库别名 远程仓库地址 #为远程仓库起别名 7. 拉取远程仓库操作12git clone 远程仓库地址 #克隆远程仓库代码到本地仓库git pull 远程仓库地址 分支名称 #获取远程仓库的最新版本 8. 解决冲突问题遇到代码冲突问题，只能人为修改以保证分支正常 9. 跨团队合作甲程序员 Fork仓库 –&gt; 甲程序员讲仓库clone到本地进行修改 –&gt; 甲程序员推送到远程 –&gt; 甲程序员发起pull request –&gt; 原作者审核 –&gt; 原作者进行合并代码 10. SSH免登陆1234生成秘钥：ssh-keygen秘钥存储目录： C：/Users/你的用户名/.ssh公钥名称：id_rsa.pub私钥名称：id_rsa 生成秘钥后，打开公钥，复制内容，在远程仓库中，Setting –&gt; SSH设置 –&gt; 添加SSH秘钥 –&gt; 粘贴添加。然后在push的时候通过ssh链接进行推送，即可实现不用账号密码登录","categories":[],"tags":[]},{"title":"关于整数二分查找及边界问题分析","slug":"关于整数二分查找及边界问题分析","date":"2021-05-22T07:22:41.000Z","updated":"2021-05-22T07:22:48.449Z","comments":true,"path":"2021/05/22/关于整数二分查找及边界问题分析/","link":"","permalink":"http://example.com/2021/05/22/%E5%85%B3%E4%BA%8E%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/","excerpt":"","text":"关于整数二分查找及边界问题分析二分查找属于分治算法。 所谓的二分算法,就是我们知道当前的候选区间中,一定存在我们要找到的答案,而且我们发现这个区间拥有单调性质此类的性质,那么我们可以不停地缩减候选区间的范围,达到排除无用答案的效果. 算法模板寻找右分界点12345678910111213int bsearch_1(int l, int r)&#123; //第二步：递归处理子问题，用while循环来实现 while (l &lt; r) &#123; //第一步：分解成子问题,这是二分的核心--范围减半 int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; //向左边找 if判断mid是否满足性质，注意该性质会划分数组的右边部分 else l = mid + 1; //向右边找 &#125; //第三步：合并子问题.对二分算法来说，不需要这一步 return l; //l就是寻找的右分界点,如果数组中没有要找的点，l的值就是r,但这是一个错误答案&#125; 寻找左分界点12345678910int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; // mid 向上取整 if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 证明待证问题：循环结束后的l就是要找的点(默认包含答案)循环不变式：[l..r]中包含答案点res 初始 显然[l..r]包含答案点res 保持 假设某轮循环开始之前,[l..r]包含答案点res 执行循环体 int mid = l + r &gt;&gt; 1 mid是向下取整得到的 if语句分支1： 如果mid满足性质，那么说明res在[l..mid]间(包括mid本身),令 r = mid if语句分支2： 如果 mid 不满足性质，说明mid在左边部分，res在[mid+1..r]间,令l = mid + 1 ∴ l和r更新之后，下一轮循环开始之前，循环不变式依然成立 终止 循环终止时， l &gt;= r 易知 l不可能比 r 大 , 故 l = r ∴ 根据循环不变式，l是答案点 res 边界分析问题：为什么 mid 是向下取整得到的，即 mid = l + r &gt;&gt; 1. 而不是向上取整,即 mid = l + r + 1 &gt;&gt; 1 答：mid向下取整是为了缩小范围，避免造成无限划分 证明if语句分支1： r = mid = l + r &gt;&gt; 1 (向下取整) 一定小于原来的 r if语句分支2： l = mid + 1 一定大于原来的 l 所以，mid向下取整的话，就不会造成无限划分 注：对于二分的另一种情况，即寻找左分界点, mid就需要向上取整了 案例题目描述给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。 输入格式第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~1000010000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤10000 输入样例： 6 31 2 2 3 3 4345 输出样例： 3 45 5-1 -1 审题在一个范围内,查找一个数字,要求找到这个元素的起始位置和结束位置,请注意这个范围内的数字都是单调递增的,即具有单调性质. 代码实现C++: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); while (m -- ) &#123; int target; scanf(&quot;%d&quot;,&amp;target); int l = 0,r = n-1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= target) r = mid; else l = mid + 1; &#125; if(q[l] != target) cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; l &lt;&lt; &#x27; &#x27;; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt;= target) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0;&#125; Java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.*;/** * @program: BinSearch01 * @description: TODO * @author: yangxun199807@163.com * @create: 2020-11-06 12:51 */class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); //数组长度 int q = sc.nextInt(); //询问个数 int arr[] = new int[n]; for (int i = 0; i &lt; arr.length; i++) arr[i] = sc.nextInt(); for (int i = 0; i &lt; q; i++) &#123; binSearch(arr); &#125; &#125; private static void binSearch(int[] arr) &#123; int l = 0, r = arr.length-1; Scanner sc = new Scanner(System.in); int target = sc.nextInt(); while (l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if (target &lt;= arr[mid]) r = mid; else l = mid + 1; &#125; if (arr[l] != target)&#123; System.out.println(&quot;-1 -1&quot;); return; &#125; else &#123; System.out.print(l + &quot; &quot;); &#125; l = 0; r = arr.length-1; while (l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if (arr[mid] &lt;= target) l = mid; else r = mid - 1; &#125; System.out.print(r); &#125;&#125;","categories":[],"tags":[]},{"title":"JVM探究","slug":"JVM探究","date":"2021-05-22T07:10:37.000Z","updated":"2021-05-22T07:10:44.492Z","comments":true,"path":"2021/05/22/JVM探究/","link":"","permalink":"http://example.com/2021/05/22/JVM%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"JVM探究JVM的位置在哪儿？ JVM的体系结构图 根据上图，对每个部分一次进行学习。 类加载器（ClassLoader）首先，先学习类加载到JVM的过程： 在如下几种情况下，Java虚拟机将结束生命周期： 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或者错误而异常终止 由于操作系统出现错误而导致Java虚拟机进行终止","categories":[],"tags":[]},{"title":"JVM运行时数据区域","slug":"JVM运行时数据区域","date":"2021-05-22T07:09:26.000Z","updated":"2021-05-22T07:09:56.421Z","comments":true,"path":"2021/05/22/JVM运行时数据区域/","link":"","permalink":"http://example.com/2021/05/22/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"运行时数据区图示图中灰色区域即为运行时数据区 1. Program Counter Register（PCR）程序计数器。内存较小，是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 线程私有，各个县城之间的计数器互不影响，独立存储。 如果线程正在执行的是一个Java方法，则记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器的值为空。 至内存区域是唯一一个在JVM中没有规定任何OOM（OutOfMemoryError）情况的区域。 2. JVM Stack线程私有，生命周期与线程相同。 每个方法执行是都会创建一个栈帧（Stack Frame），栈帧包括如下： 局部变量表 存放编译器可知的8种基本数据类型以及对象引用类型(reference) 其中64位长度的long和double类型会占两个Slot，其余的只占一个 局部变量表所需内存在编译期间就一完成分配 操作数栈 动态链接 返回地址 方法出口 异常情况 StackOverFlowError OutOfMemoryError … 3. Naive Method Stack线程私有，执行的是Native方法。异常情况与JVM Stack相同。 关于Native方法: A native method is a Java method whose implementation is provided by non-java code. 意思就是Native方法就是该方法的实现是由其他语言实现，而并非Java。在Java诞生的时候，还是C和C++的天下，Java一方面为了迎合市场，一方面为了弥补Java的不足，便有了这个机制。 4. Java HeapJava Heap是JVM种占内存最大的一块。此内存区域线程共享。在虚拟机启动时创建。 此内存作用就是用来存储对象实例。因此它也是GC的重点区域。 结构Java Heap的内部还根据内存回收的角度，对其区域进行分代： 新生代 Eden区 From Survivor空间（S1区） To Survivor空间（S2区） 老年代 从内存分配的角度看，线程共享的堆中坑划分出多个线程私有的TLAB（Thread Local Allocation Buffer），即内存缓冲区。 在物理内存中，Java Heap是不连续的内存空间，只要逻辑上是连续的即可。 5. Method Area关于永久代和元空间、方法区的区别方法区属于JVM规范中的定义，而永久代是一种实现。也就是说方法区属于一个标准，而永久代是HotSpot对于这个标准的实现。在Java8之后，HotSpot进行了“去永久代”，把永久代取消，取而代之的是元空间。 而元空间和永久代的区别在于存储位置的不同，永久代在物理上是堆的一部分和新生代，老年代的存储地址是连续的，只是在逻辑上不是(当时也被称作 Non Heap Memory)；而元空间属于本地内存。还有一点就是在存储的内容不同，元空间用来准出类的元信息，而静态变量和常量池被并入到了Java Heap中。可以理解为，永久代的数据被分到了Java Heap和元空间中。 用途用于存储被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 6. Runtime Constant Pool（运行时常量池） 运行时常量池是方法区的一部分，是一块内存区域。运行时常量池将在类加载后进入方法区的运行时常量池中存放。一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。 7. Direct Memory（直接内存）一般是NIO类（New Input/Output）使用这块内存较多。 此内存区域并不属于运行时数据区，也不是JVM规范中定义的内存区域，因此，它只有可能出现OutOfMemoryError。","categories":[],"tags":[]},{"title":"内存分配与回收策略","slug":"内存分配与回收策略","date":"2021-05-22T07:08:46.000Z","updated":"2021-05-22T07:09:12.251Z","comments":true,"path":"2021/05/22/内存分配与回收策略/","link":"","permalink":"http://example.com/2021/05/22/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/","excerpt":"","text":"内存分配与回收策略年轻代 对象主要分配在新生代的Eden区域 启动本地线程分配缓存的话,则优先在TLAB上分配 优先将对象分配在新生代上,Eden区域内存不够时发送Minor GC 老年代 大对象直接进入老年代 长期存活的对象进入老年代 注意:可以配置参数指定大于多大对象直接进入老年代,防止年轻代内存复制频繁 当对象在Eden区域时经历了第一次Minor GC的时候,并且移动到Survivor区域时,这个时候它的年龄为1,每熬过一次Minor GC,年龄加1,当年龄达到一定程度的话(默认为15岁),那么晋升到老年代. 为了更好的适应不同程序的内存情况,虚拟机并不是完全按照对象年龄计算的。如果在Survivor空间中相同年龄的对象总和大于或者等于Survivor空间的一半时,那么等于和大于这个年龄的对象都会进入老年代。 Minor GC之前,JVM会判断老年代最大可用的内存是否大于年轻代所有对象内存总和,条件成立那么认为是安全的 如果不成立,尝试进行一次Minor GC,这个是有风险的,因为老年代剩余的内存可能不够 老年代会判断历史晋升到老年代对象的平均值是否大于老年代剩余的内存,以便于是FULL GC 来腾出更多的内存 内存担保失败的话就Full GC","categories":[],"tags":[]},{"title":"类加载、类加载器、双亲委派","slug":"类加载、类加载器、双亲委派","date":"2021-05-22T07:08:04.000Z","updated":"2021-05-22T07:08:32.021Z","comments":true,"path":"2021/05/22/类加载、类加载器、双亲委派/","link":"","permalink":"http://example.com/2021/05/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/","excerpt":"","text":"类加载、类加载器、双亲委派1. 类加载定义虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。类加载和连接的过程都是在运行期间完成的。 加载方式 本地编译好的class中直接加载 网络加载：java.net.URLClassLoader可以加载url指定的类 从jar、zip等等压缩文件加载类，自动解析jar文件找到class文件去加载util类 从java源代码文件动态编译成为class文件 类加载的生命周期加载（Loading）–&gt;验证（Verification）–&gt;准备（Preparation）–&gt;解析（Resolution）–&gt;初始化（Initialization）–&gt;使用（Using）–&gt;卸载（Unloading） 过程详解 加载 A. 加载阶段的工作： ​ i. 通过一个类的全限定名来获取定义此类的二进制字节流。 ​ ii. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 ​ iii. 在java堆中生成一个代表这个类的java.lang.Class对象，做为方法区这些数据的访问入口。 B. 加载阶段完成之后二进制字节流就按照虚拟机所需的格式存储在方区去中。 验证 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。 ​ a) 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 ​ b) 元数据验证：对字节码描述的信息进行语义分析，以确保其描述的信息符合java语言规范的要求。 ​ c) 字节码验证：这个阶段的主要工作是进行数据流和控制流的分析。任务是确保被验证类的方法在运行时不会做出危害虚拟机安全的行为。 ​ d) 符号引用验证：这一阶段发生在虚拟机将符号引用转换为直接引用的时候（解析阶段），主要是对类自身以外的信息进行匹配性的校验。目的是确保解析动作能够正常执行。 准备 准备阶段是正式为变量分配内存并设置初始值，这些内存都将在方法区中进行分配，这里的变量仅包括类标量不包括实例变量。 注意：这里的初始值不能弄混，比如说，int i = 666 在这个步骤的赋初始值是给i赋了0值，而非666。 解析 解析是虚拟机将常量池的符号引用替换为直接引用的过程。 a) 类或接口的解析 b) 字段的解析 c) 类方法解析 d) 接口方法解析 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接饮用是与内存布局相关的。 初始化 是根据程序员制定的主观计划区初始化变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器()方法的过程。（参考3中，此时的初始化才是给i赋666值的阶段） 2. 类加载器JVM中定义的有3中类加载器。分别是：启动（Bootstrap）类加载器、标准扩展（Extension）类加载器、应用类(App)加载器。 启动（Bootstrap）类加载器c++编写，加载java核心库 java.*,构造ExtClassLoader和AppClassLoader。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作 标准扩展（Extension）类加载器扩展类加载器是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader） 实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 应用（App）类加载器应用类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。 CustomClassLoader（用户自定义类加载器）java编写,用户自定义的类加载器,可加载指定路径的class文件 3. 双亲委派机制上源码12345678910111213141516171819202122232425262728293031protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 首先检查这个classsh是否已经加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // c==null表示没有加载，如果有父类的加载器则让父类加载器加载 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; //如果父类的加载器为空 则说明递归到bootStrapClassloader了 //bootStrapClassloader比较特殊无法通过get获取 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123;&#125; if (c == null) &#123; //如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class long t1 = System.nanoTime(); c = findClass(name); sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 双亲委派是什么俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和标准扩展类加载器为例作简单分析。 类加载器模型图","categories":[],"tags":[]},{"title":"垃圾回收算法","slug":"垃圾回收算法","date":"2021-05-22T07:06:28.000Z","updated":"2021-05-22T07:07:19.024Z","comments":true,"path":"2021/05/22/垃圾回收算法/","link":"","permalink":"http://example.com/2021/05/22/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","excerpt":"","text":"垃圾回收算算法1. Mark-Sweep（标记-清除算法）首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 缺点：标记和清除过程的效率都不高;还容易产生大量不连续的内存碎片 步骤图示： 2. Coping（复制算法）内存按容量划分为大小相等的两块，一块内存用完了,将存活着的对象复制到另外一块将都是垃圾对象的那块清空内存。 优点：速度贼快，无空间碎片 缺点：在对象存活率较高时，复制操作次数多，效率降低；內存缩小了一半;需要額外空间做分配担保(老年代) 步骤图示： 3. Mark-Compact（标记-整理法）标记步骤和标记清除算法相同，标记完后垃圾对象移动到一端,然后在清理掉。 缺点：很明显，效率很低 步骤图示： 4. Generational Collection（分代收集算法）根据以上三种方法可知，每种都有自己的有点和缺点。因此没有最好的算法，只有最合适的算法，因此我们在朝生夕死的新生代，使用效率较高的Coping算法，在CG不是特别频繁，且需要用来做Handle Promotion（空间担保）的老年区使用Mark-Compact算法或者Mark-Sweep算法。","categories":[],"tags":[]},{"title":"策略模式(Stratagy)","slug":"策略模式","date":"2021-05-22T06:45:30.000Z","updated":"2021-05-22T06:54:18.720Z","comments":true,"path":"2021/05/22/策略模式/","link":"","permalink":"http://example.com/2021/05/22/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式(Stratagy)定义策略模式 定义一系列算法，把他们独立封装起来，并且这些算法之间可以相互替换。策略模式主要是管理一堆有共性的算法，策略模式让算法独立于使用它的客户而变化，客户端可以根据需要，很快切换这些算法，并且保持可扩展性。 比如说，我有一个排序方法，但是这个排序的规则有好几种，比如说，针对一个实体类的id进行排序，也可以针对实体类的age进行排序等等还多中规则，这些规则我都是可以随时替换的。而策略模式就是来处理这一类问题。 优缺点优点： 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点： ​ 策略模式造成很多的策略类。 原理策略模式的原理图如下： Strategy类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法。 Concrete Strategy类：实现了抽象策略定义的接口，也就是真正干活的类 Context类：持有一个策略类的引用，最终给客户端调用 注意：Context也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 举个例子此时要开发一款软件，可以使用Java，也可以使用PHP，这两个语言属于两个策略。现在使用策略模式来实现这个问题。 抽象语言类 123public interface CodeLanguage &#123; void useLanguage();&#125; 具体语言类 123456public class CodeJava implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(&quot;使用Java语言编程&quot;); &#125;&#125; 123456public class CodePhp implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(&quot;使用Php语言编程&quot;); &#125;&#125; 策略引用类 1234567891011public class CodeContext &#123; CodeLanguage codeLanguage; public CodeContext1(CodeLanguage codeLanguage) &#123; this.codeLanguage = codeLanguage; &#125; void useLanguage()&#123; codeLanguage.useLanguage(); &#125;&#125; 使用模式 123456789public class Application &#123; public static void main(String[] args) &#123; CodeContext context; context = new CodeContext(new CodeJava()); context.useLanguage(); context = new CodeContext(new CodePhp()); context.useLanguage(); &#125;&#125; 此时，这个模型就已经用代码表示出来了，此时我们也不难发现，如果现在需要再增加一种策略的话，只需要新建一个CodeLanguage的实现类就可以了，在使用的时候可以直接调用策略。体现了它的扩展性","categories":[],"tags":[]},{"title":"垃圾回收器","slug":"垃圾回收器","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T07:03:03.228Z","comments":true,"path":"2021/05/22/垃圾回收器/","link":"","permalink":"http://example.com/2021/05/22/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","excerpt":"","text":"垃圾回收器1. 常见的垃圾回收器新生代收集器： Serial ParNew Parallel Scavenge 老年代回收器： Serial Old CMS Parallel Old 堆内存垃圾收集器： G1 他们之间的关系如下图： 如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。 2. 新生代垃圾收集器Serial 收集器Serial 是一款用于新生代的单线程收集器，采用复制算法进行垃圾收集。Serial 进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World）。如图： 当用户线程都执行到安全点时，所有线程暂停执行，Serial 收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行。 优点：简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个cpu来说没有了上下文之间的的切换，效率比较高。 缺点：会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。 适用场景：Client 模式（桌面应用）；单核服务器。 设置参数：可以用 -XX:+UserSerialGC 来选择 Serial 作为新生代收集器。 ParNew 收集器ParNew 就是一个 Serial 的多线程版本，其它与Serial并无区别。ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果，它默认开启的收集线程数和 CPU 数量一致，可以通过 -XX:ParallelGCThreads 来设置垃圾收集的线程数。如图： 优点：随着cpu的有效利用，对于GC时系统资源的有效利用有好处。 适用场景：ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器。因为CMS收集器只能与serial或者parNew联合使用，在当下多核系统环境下，首选的是parNew与CMS配合。ParNew收集器也是使用CMS收集器后默认的新生代收集器。 参数：可以用 -XX:UseParNewGC来选择新生代采用ParNew收集器 关于Parralel（并行）和Concurrent（并发） Parralel（并行）：指多条垃圾收集线程并行工作、但此时用户线程仍然处于等待状态 Concurrent（并发）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，也可能是交替执行的），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。 Parallel Scavenge 收集器Parallel Scavenge 也是一款用于新生代的多线程收集器，与 ParNew 的不同之处是ParNew 的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge 的目标是达到一个可控制的吞吐量。 例如虚拟机一共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那吞吐量就是 99% 。比如下面两个场景，垃圾收集器每 100 秒收集一次，每次停顿 10 秒，和垃圾收集器每 50 秒收集一次，每次停顿时间 7 秒，虽然后者每次停顿时间变短了，但是总体吞吐量变低了，CPU 总体利用率变低了。其与Parallel Old收集器运行示意图如下 适用场景：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互。 参数： XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间 XX:GCRatio 直接设置吞吐量的大小。 3. 老年代垃圾收集器Serial Old 收集器Serial Old 收集器是 Serial 的老年代版本，同样是一个单线程收集器，采用标记-整理算法。如图： 适用场景：Client 模式（桌面应用）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案。 Parallel Old 收集器是Parallel Scavenge收集器的老年代版本。如图： 适用场景：与Parallel Scavenge 收集器搭配使用；注重吞吐量。 参数：使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器。 CMS(Concurrent Mark Sweep) 收集器CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤： 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快。 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长。 重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短。 并发清除：用标记-清除算法清除垃圾对象，耗时较长。 整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的。如图： 优点： 并发收集、低停顿 缺点: 对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小 无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。 因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC. 适用场景：重视服务器响应速度，要求系统停顿时间最短。 参数：可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器 4. 新生代和老年代垃圾收集器G1 收集器一款面向服务端应用的垃圾收集器。G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region，如下图： 每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M。 为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。 G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。 如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似： 步骤： 初始标记：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。 并发标记：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。 最终标记：修正在并发标记阶段引用户程序执行而产生变动的标记记录。 筛选回收：筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。 适用场景：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器。","categories":[],"tags":[]},{"title":"动态代理（Dynamic Proxy）","slug":"动态代理","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:47:50.200Z","comments":true,"path":"2021/05/22/动态代理/","link":"","permalink":"http://example.com/2021/05/22/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"动态代理（Dynamic Proxy）1.定义原理和静态代理相同，只是为了解决静态代理的缺点。详情请点静态代理 2. 优缺点优点除了静态代理的优点外，还解决了静态代理的短板，可以动态生成代理类，大大减少了代码量。 缺点由于用的是反射的原理，性能相对较低。 3. 步骤角色： 接口类 实现类：被代理的类 代理类：必须实现InvocationHandler接口 4. 代码为了更加形象地理解JDK动态代理的使用流程，举个栗子。 今天，小黑要和王美丽去相亲，但是由于王美丽和小黑是第一次见面，小黑不好意思直接去找她的家人邀请她去约会和看电影。先看代码： Girl接口和王美丽的实体类： 12345678910111213package com.yang.proxy.demo2;/** * @program: Girl * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:47 */public interface Girl &#123; public void date(); public void watchMovie();&#125; 12345678910111213141516171819package com.yang.proxy.demo2;/** * @program: WangMeiLi * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:46 */public class WangMeiLi implements Girl &#123; public void date() &#123; System.out.println(&quot;王美丽：长得好看就行&quot;); &#125; public void watchMovie() &#123; System.out.println(&quot;王美丽：和你看电影很开心&quot;); &#125;&#125; 代理类： 123456789101112131415161718192021222324252627282930313233343536373839package com.yang.proxy.demo2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @program: MyProxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:55 */public class MyProxy implements InvocationHandler &#123; private Object target; public MyProxy(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Dad(); Object invoke = method.invoke(target, args); Mom(); return invoke; &#125; public Object getInstance()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; public void Dad()&#123; System.out.println(&quot;对你好不好?&quot;); &#125; public void Mom()&#123; System.out.println(&quot;有房吗？有车吗？&quot;); &#125;&#125; 小黑通过王美丽的家人去约她，王美丽的动作很单纯，值管看电影和看人家小黑好不好看。但是她的家人（代理类）可不放心，她的家人还要在invoke()方法里进行方法增强，比图说，她爸爸要看小黑对她好不好，她妈妈要看小黑有没有房和车。增强后才放心地用getInstance()方法让女儿去和小黑约会。 现在使用测试类进行测试： 123456789101112131415161718192021package com.yang.proxy.demo2;/** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */public class Demo &#123; public static void main(String[] args) &#123; WangMeiLi wangMeiLi = new WangMeiLi(); XiaoHei xiaoHei = new XiaoHei(); MyProxy families = new MyProxy(wangMeiLi); Girl wmother = (Girl) families.getInstance(); wmother.date(); wmother.watchMovie(); &#125;&#125; 结果如下： 对你好不好?王美丽：长得好看就行有房吗？有车吗？对你好不好?王美丽：和你看电影很开心有房吗？有车吗？ 此时，基础的代理功能已经达到了，但是还没有测试动态这个特点。因此我们现在创建一个Boy接口和小黑的类。 123456package com.yang.proxy.demo2;public interface Boy &#123; public void date(); public void watchMovie();&#125; 123456789101112131415161718package com.yang.proxy.demo2;/** * @program: XiaoHei * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 20:39 */public class XiaoHei implements Boy &#123; public void date() &#123; System.out.println(&quot;好看就行&quot;); &#125; public void watchMovie() &#123; System.out.println(&quot;电影不好看&quot;); &#125;&#125; 现在我们没有为小黑做任何的代理类，现在我们用这个动态代理类进行测试： 1234567891011121314151617181920package com.yang.proxy.demo2;/** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */public class Demo &#123; public static void main(String[] args) &#123; XiaoHei xiaoHei = new XiaoHei(); MyProxy heiFamilies = new MyProxy(xiaoHei); Boy hMother = (Boy) heiFamilies.getInstance(); hMother.date(); hMother.watchMovie(); &#125;&#125; 结果如下： 对你好不好?小黑:好看就行有房吗？有车吗？对你好不好?小黑:电影不好看有房吗？有车吗？ 可见，测试成功！","categories":[],"tags":[]},{"title":"工厂模式（Factory Pattern）","slug":"工厂模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:55:04.855Z","comments":true,"path":"2021/05/22/工厂模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式工厂设计模式，就是用来生产对象的，在Java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则，如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦 一共有3中工厂设计模式：简单工厂、工厂方法、抽象工厂 简单工厂设计模式一个工厂方法，依据传入的参数，生成对应的产品对象。 共有3个角色：抽象产品、局具体产品、具体工厂 代码实现水果接口： 123public interface Fruit &#123; void whatIm();&#125; 具体类： 123456public class Apple implements Fruit &#123; @Override public void whatIm() &#123; //苹果 &#125;&#125; 123456public class Pear implements Fruit &#123; @Override public void whatIm() &#123; //梨 &#125;&#125; 具体工厂： 123456789101112public class FruitFactory &#123; public Fruit createFruit(String type) &#123; if (type.equals(&quot;apple&quot;)) &#123;//生产苹果 return new Apple(); &#125; else if (type.equals(&quot;pear&quot;)) &#123;//生产梨 return new Pear(); &#125; return null; &#125;&#125; 使用产品： 123FruitFactory mFactory = new FruitFactory();Apple apple = (Apple) mFactory.createFruit(&quot;apple&quot;);//获得苹果Pear pear = (Pear) mFactory.createFruit(&quot;pear&quot;);//获得梨 缺点这个设计模式的缺点显而易见，当我需要添加一种水果的时候，我不但需要新建一个水果的类，还需要修改工厂类。违反了开闭原则。因此，它只使用于产品数较少，产品变化的需求较少的场景。 工厂方法设计模式将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定。 共有4个角色：抽象产品类、具体产品类、抽象工厂类、具体工厂类 代码实现工厂接口： 123public interface FruitFactory &#123; Fruit createFruit();//生产水果&#125; 苹果工厂： 123456public class AppleFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Apple(); &#125;&#125; 梨工厂： 123456public class PearFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Pear(); &#125;&#125; 使用： 1234AppleFactory appleFactory = new AppleFactory();PearFactory pearFactory = new PearFactory();Apple apple = (Apple) appleFactory.createFruit();//获得苹果Pear pear = (Pear) pearFactory.createFruit();//获得梨 缺点这种方式，虽然解耦成功，也遵循了开闭原则，但是最根本的问题依然存在，如果需要增加水果的话，还得创建大量的工厂类，很麻烦。 抽象工厂设计模式为创建一组相关或者是相互依赖的产品族提供的一个接口，而不需要指定它们的具体类。 代码实现cpu接口和实现类： 1234567891011121314151617public interface Cpu &#123; void run(); class Cpu650 implements Cpu &#123; @Override public void run() &#123; //625 也厉害 &#125; &#125; class Cpu825 implements Cpu &#123; @Override public void run() &#123; //825 处理更强劲 &#125; &#125;&#125; 屏幕和接口实现类： 1234567891011121314151617181920public interface Screen &#123; void size(); class Screen5 implements Screen &#123; @Override public void size() &#123; //5寸 &#125; &#125; class Screen6 implements Screen &#123; @Override public void size() &#123; //6寸 &#125; &#125;&#125; 工厂接口： 123456public interface PhoneFactory &#123; Cpu getCpu();//使用的cpu Screen getScreen();//使用的屏幕&#125; 实现： 123456789101112public class HongMiFactory implements PhoneFactory &#123; @Override public Cpu getCpu() &#123; return new Cpu.Cpu650();//高效处理器 &#125; @Override public Screen getScreen() &#123; return new Screen.Screen5();//小屏手机 &#125;&#125; 以上例子可以看出，抽象工厂可以解决一系列的产品生产的需求，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展； 总结 对于简单工厂和工厂方法来说，两者的使用方式实际是一样的，对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式。毕竟效果都一样，何必要用一个写起来更麻烦的方法呢。 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产。","categories":[],"tags":[]},{"title":"建造者模式（Builder Patttern）","slug":"建造者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:53:41.025Z","comments":true,"path":"2021/05/22/建造者模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式（Builder Patttern）在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。这时就需要建造者模式来解决。 1. 定义指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 2. 优缺点优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 3. 原理主要角色 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：也叫导演类，它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 结构图 实现步骤 创建抽象建造者定义造房步骤 创建工人具体实现造房步骤 创建承包商指挥工人施工 验收，检查是否建造完成 4. 代码实现产品类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.yang.builder;/** * @program: Product * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:41 */public class Product &#123; private String buildA; private String buildB; private String buildC; private String buildD; public String getBuildA() &#123; return buildA; &#125; public void setBuildA(String buildA) &#123; this.buildA = buildA; &#125; public String getBuildB() &#123; return buildB; &#125; public void setBuildB(String buildB) &#123; this.buildB = buildB; &#125; public String getBuildC() &#123; return buildC; &#125; public void setBuildC(String buildC) &#123; this.buildC = buildC; &#125; public String getBuildD() &#123; return buildD; &#125; public void setBuildD(String buildD) &#123; this.buildD = buildD; &#125; @Override public String toString() &#123; return &quot;Product&#123;&quot; + &quot;buildA=&#x27;&quot; + buildA + &#x27;\\&#x27;&#x27; + &quot;, buildB=&#x27;&quot; + buildB + &#x27;\\&#x27;&#x27; + &quot;, buildC=&#x27;&quot; + buildC + &#x27;\\&#x27;&#x27; + &quot;, buildD=&#x27;&quot; + buildD + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 建造类123456789101112131415161718package com.yang.builder;/** * @program: Build * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:43 */public abstract class Build &#123; public abstract Build setBuildA(); public abstract Build setBuildB(); public abstract Build setBuildC(); public abstract Build setBuildD(); public abstract Product getProduct();&#125; 具体建造者类1234567891011121314151617181920212223242526272829303132333435363738394041package com.yang.builder;/** * @program: Worker * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:45 */public class Worker extends Build &#123; private Product product; public Worker() &#123; product = new Product(); &#125; public Build setBuildA() &#123; product.setBuildA(&quot;地基&quot;); return this; &#125; public Build setBuildB() &#123; product.setBuildB(&quot;钢金&quot;); return this; &#125; public Build setBuildC() &#123; product.setBuildC(&quot;水电&quot;); return this; &#125; public Build setBuildD() &#123; product.setBuildD(&quot;粉刷&quot;); return this; &#125; public Product getProduct() &#123; return product; &#125;&#125; 导演类1234567891011121314151617package com.yang.builder;/** * @program: Derict * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:48 */public class Derict &#123; public Product create(Build build)&#123; build.setBuildA().setBuildB().setBuildC().setBuildD(); return build.getProduct(); &#125;&#125; 客户类1234567891011121314151617package com.yang.builder;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:50 */public class MyDemo &#123; public static void main(String[] args) &#123; Derict derict = new Derict(); Product product = derict.create(new Worker()); System.out.println(product); &#125;&#125;","categories":[],"tags":[]},{"title":"模板模式（Template Pattern）","slug":"模板模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:54:05.920Z","comments":true,"path":"2021/05/22/模板模式/","link":"","permalink":"http://example.com/2021/05/22/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板模式（Template Pattern）完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。这就是模板模式。 1. 定义定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 2. 优缺点优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 3. 原理角色 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中申明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 结构图 4. 代码实现老规矩，举个栗子。迎接客人，而这个迎接客人的流程是一样的，都是visit、talk、bye。但是根据客人身份的不同，实现的方式也不同，这里设定的是两种客人，一种是儿子带女朋友回家，一个是女儿带男朋友回家。 抽象类： 123456789101112131415161718192021/** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */public abstract class Welcome &#123; public abstract void visit(); public abstract void talk(); public abstract void bye(); public void run()&#123; visit(); talk(); bye(); &#125;&#125; 迎接儿子女朋友的实现类： 12345678910111213141516171819202122package com.yang.template;/** * @program: LoverOfSon * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:51 */public class LoverOfSon extends Welcome &#123; public void visit() &#123; System.out.println(&quot;来就来嘛还带这么多东西&quot;); &#125; public void talk() &#123; System.out.println(&quot;这姑娘真不错&quot;); &#125; public void bye() &#123; System.out.println(&quot;20w彩礼，你看看够不够，不够我们再加&quot;); &#125;&#125; 迎接女儿男朋友的实现类： 12345678910111213141516171819202122package com.yang.template;/** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(&quot;除了华子，送别的烟我不抽，拉嗓子&quot;); &#125; public void talk() &#123; System.out.println(&quot;有车吗？有房吗？有什么学位？&quot;); &#125; public void bye() &#123; System.out.println(&quot;没50w彩礼别想娶我家姑娘&quot;); &#125;&#125; 测试类： 1234567891011121314151617181920package com.yang.template;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:56 */public class MyDemo &#123; public static void main(String[] args) &#123; Welcome loverOfSon = new LoverOfSon(); loverOfSon.run(); System.out.println(); Welcome loverOfDaughter = new LoverOfDaughter(); loverOfDaughter.run(); &#125;&#125; 运行结果 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？没50w彩礼别想娶我家姑娘 可见这个模式已经实现。但是此时还有一个新问题，如果说客人来了，还得吃饭，老头还得喝点。那么就需要在Welcome流程里加一个喝酒类，但是也不行，如果是儿子带女朋友回来的话，让人一姑娘喝酒也不合适。这时我们要解决的问题就是，通过子类的操作来实现，对父类流程的调控。因此我们用了一个钩子方法来解决这个问题。下面我们对上面的代码进行改造。 Welcaome类： 1234567891011121314151617181920212223242526272829303132package com.yang.template;/** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */public abstract class Welcome &#123; protected boolean isDrink()&#123; return false; &#125; protected abstract void visit(); protected abstract void talk(); protected abstract void bye(); protected void Drink()&#123; System.out.println(&quot;哈啤酒~~~&quot;); &#125; public void run()&#123; visit(); talk(); if (isDrink())&#123; Drink(); &#125; bye(); &#125;&#125; LoverOfDaughter类： 1234567891011121314151617181920212223242526272829303132package com.yang.template;/** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(&quot;除了华子，送别的烟我不抽，拉嗓子&quot;); &#125; public void talk() &#123; System.out.println(&quot;有车吗？有房吗？有什么学位？&quot;); &#125; @Override protected boolean isDrink() &#123; return true; &#125; @Override protected void Drink() &#123; System.out.println(&quot;喝白的&quot;); &#125; public void bye() &#123; System.out.println(&quot;没50w彩礼别想娶我家姑娘&quot;); &#125;&#125; 其他类保持原样，运行之后的效果如下： 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？喝白的没50w彩礼别想娶我家姑娘 我们以上的问题已经解决，在这次改进中，我给isDrick()方法了初始值，就是不喝，也给了Drink()方法了初始值。这样子类就可以根据需要进行选择重写或者不重写。 这就是我们的模板模式，看完之后可能第一感觉就是，非常熟悉。是的，我们的编码过程中，经常使用，但是不知道它的名字而已。设计模式仅仅是一个设计过程中的技巧和模式。在实际开发中，知不知道他的名字无所谓，到了使用的时候，自然就用出来了。这就是传说中的，无招胜有招。","categories":[],"tags":[]},{"title":"静态代理模式（Static Proxy）","slug":"静态代理模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:53:50.822Z","comments":true,"path":"2021/05/22/静态代理模式/","link":"","permalink":"http://example.com/2021/05/22/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"静态代理模式（Static Proxy）1. 定义给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。防止直接访问目标对象给系统带来的不必要复杂性。 2. 优缺点优点 可以使真是角色的操作更加纯粹，不用去关心一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点 一个真是角色会产生一个代理角色，代码量翻倍，开发效率低！ 实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 3. 原理角色 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 结构图 实现步骤 创建抽象对象接口（Subject） 创建真实对象类（RealSubject） 创建代理对象类（Proxy） 客户端调用 4. 代码实现比如，现在我要租一个房子，但是我又不想自己去找房东，也不想自己去谈价钱，看房子这些破事儿，我就可以去找中介代理帮我做。 创建一个Rent接口12345package com.yang.proxy.demo1;public interface Rent &#123; public void rentRoom();&#125; 创建一个真实对象类1234567891011121314package com.yang.proxy.demo1;/** * @program: Client * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:52 */public class Client implements Rent &#123; public void rentRoom() &#123; System.out.println(&quot;我是客户，我要租房子&quot;); &#125;&#125; 创建代理对象类12345678910111213141516171819202122232425262728293031323334package com.yang.proxy.demo1;/** * @program: Proxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:53 */public class Proxy implements Rent &#123; private Client client; public Proxy() &#123; &#125; public Proxy(Client client) &#123; this.client = client; &#125; public void rentRoom() &#123; lookRoom(); client.rentRoom(); bargin(); &#125; public void bargin()&#123; System.out.println(&quot;我是中介，我在讲价&quot;); &#125; public void lookRoom()&#123; System.out.println(&quot;我是中介，我在看房&quot;); &#125;&#125; 调用12345678910111213141516package com.yang.proxy.demo1;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:54 */public class MyDemo &#123; public static void main(String[] args) &#123; Client client = new Client(); Proxy proxy = new Proxy(client); proxy.rentRoom(); &#125;&#125;","categories":[],"tags":[]},{"title":"观察者模式（Observer Pattern）","slug":"观察者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:53:30.230Z","comments":true,"path":"2021/05/22/观察者模式/","link":"","permalink":"http://example.com/2021/05/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式（Observer Pattern）在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。 1. 定义指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 2. 优缺点优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 3. 实现角色 抽象对象（IObject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体对象（Concrete Object）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 模式图 4. 代码抽象对象类： 123456789101112131415161718192021222324252627282930package com.yang.observe;import java.util.ArrayList;import java.util.List;/** * @program: IObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:02 */public abstract class IObject &#123; protected List&lt;IObserver&gt; list=new ArrayList&lt;IObserver&gt;(); //增加观察者方法 public void add(IObserver observer) &#123; list.add(observer); &#125; //删除观察者方法 public void remove(IObserver observer) &#123; list.remove(observer); &#125; //通知观察者方法 public abstract void notifyObserver();&#125; 具体对象类： 123456789101112131415161718package com.yang.observe;/** * @program: ConcreteObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:05 */public class ConcreteObject extends IObject &#123; public void notifyObserver() &#123; System.out.println(&quot;目标角色发生了变化&quot;); for (IObserver observer : super.list) &#123; observer.response(&quot;ConcreteObject发生变化&quot;); &#125; &#125;&#125; 观察者接口： 123456789101112package com.yang.observe;/** * @program: IObserver * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */public interface IObserver &#123; public void response(String msg);&#125; 具体观察者1 123456789101112131415package com.yang.observe;/** * @program: Observer * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */public class Observer1 implements IObserver&#123; public void response(String msg) &#123; System.out.println(&quot;Observer01知道了[&quot; + msg + &quot;]&quot; ); &#125;&#125; 具体观察者2： 123456789101112131415package com.yang.observe;/** * @program: Observer2 * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:10 */public class Observer2 implements IObserver&#123; public void response(String msg) &#123; System.out.println(&quot;Observer02知道了[&quot; + msg + &quot;]&quot; ); &#125;&#125; 测试类： 1234567891011121314151617181920package com.yang.observe;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:11 */public class MyDemo &#123; public static void main(String[] args) &#123; Observer1 observer1 = new Observer1(); Observer2 observer2 = new Observer2(); ConcreteObject concreteObject = new ConcreteObject(); concreteObject.add(observer1); concreteObject.add(observer2); concreteObject.notifyObserver(); &#125;&#125; 运行结果： 目标角色发生了变化Observer01知道了[ConcreteObject发生变化]Observer02知道了[ConcreteObject发生变化]","categories":[],"tags":[]},{"title":"对象的内存布局和创建","slug":"对象的内存布局和创建","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T07:01:07.729Z","comments":true,"path":"2021/05/22/对象的内存布局和创建/","link":"","permalink":"http://example.com/2021/05/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%88%9B%E5%BB%BA/","excerpt":"","text":"对象的内存布局和创建1. 对象的内存布局对象的内存布局分为3个区域：Header（对象头）、Instance Data（实例数据）、Padding（对齐填充） Header（对象头） 运行时的数据（Mark Word）：如HashCode（哈希码）、GC分代年龄、锁状态标志、线程持有的锁等等 类型指针：通过这个指针确定这个对象属于哪个类 Instance Data（实例数据）这部分是存储真正的有效信息，也就是在程序代码中所定义的各种类型的字段内容。 Padding（对齐填充）这部分信息没有任何意义，仅仅是为了使得对象占的内存大小为8字节的整数倍。 2. 对象的创建在语言层面，使用new关键字即可创建出一个对象。但是在虚拟机中，对象创建的创建过程则是比较复杂的。 (1) 首先，虚拟机运到new指令时，会去常量池检查是否存在new指令中包含的参数，比如new People(),则虚拟机首先会去常量池中检查是否有Student这个类的符号引用，并且检查这个类是否已经被加载了，如果没有则会执行类加载过程。 (2) 在类加载检查过后，接下来为对象分配内存当然是在java堆中分配。 (3) 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也许会提前值TLAB分配时进行。这一步保证了对象实例字段在Java中不赋值也可以直接使用。 (4) 接来下，虚拟机对对象进行必要的设置，例如这个对象属于哪个类的实例，如何找到类的元数据信息。对象的哈希吗、对象的GC年代等信息，这些信息都存放在对象头之中。 (5) 执行完上面工作之后，所有的字段都为0，接着执行指令，把对象按照程序员的指令进行初始化，这样一个对象就完整的创建出来。 这就完了吗？？？？当然没有！！请往下看！ 3. 对象空间的分配Java堆为对象分配内存的方式有两种：Bump the Pointer(指针碰撞)和Free List(空闲列表) **Bump the Pointer(指针碰撞)**：假设Java堆中的内存都放在一起，所有是使用过的内存放到一边，空闲的内存放到另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅把指针相空闲空间的方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞” **Free List(空闲列表)**：当使用内存和空闲内存交织在一起时，JVM需要维护一个列表，记录哪些内存是可用的，在给对象分配内存时从列表中找到一块足够大的内存空间划分给对象，并更新列表上的记录。这种分配方式称之为“空闲列表” Java Heap内存采用哪种分配方式取决于Java Heap内存是否带有空间压缩整理的能力决定。也就是说有垃圾回收器采用哪种回收算法来决定的。当垃圾回收器采用的是标记-清理算法，如CMS垃圾回收器，那么使用的就是空闲列表的分配方式。当使用Serial、parNew等带有压缩整理过程的收集器，采用的是指针碰撞的内存分配方式 4. 对象的访问对象的访问方式主流的有两种：句柄访问方式和直接指针访问方式 句柄访问方式在Java堆中划分一块内存来作为句柄池，句柄池中包含了对象数据和对象类型的具体地址信息。通过这些信息可以访问到对象实例数据和对象类型数据。Java栈中的reference存储对象的句柄池地址即可。如图： 直接指针访问方式reference中存储的就是对象地址。如图： 二者优势句柄访问方式的优势就是稳定，reference中存储的是稳定的句柄地址，在对象移动时只会改变句柄中实例数据的指针，而reference本身不被修改。 直接访问方式的优势就是速度快，节省了指针定位的时间开销 HotSpot虚拟机采用的是直接指针访问方式","categories":[],"tags":[]},{"title":"单例模式(Singleton Pattern)","slug":"单例模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:50:14.700Z","comments":true,"path":"2021/05/22/单例模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式在有些开发场景中，没有必要有多个实例存在，以节省资源。比如说 PropertiyMgr 工具类 饿汉式实现代码如下： 12345678910111213141516171819public class Mgr01 &#123; private static final Mgr01 INSTANCE = new Mgr01(); private Mgr01() &#123;&#125;; public static Mgr01 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr01 m1 = Mgr01.getInstance(); Mgr01 m2 = Mgr01.getInstance(); System.out.println(m1 == m2); &#125;&#125; 还有一种写法，和上面的写法效果一模一样： 12345678910111213141516171819202122public class Mgr02 &#123; private static final Mgr02 INSTANCE; static &#123; INSTANCE = new Mgr02(); &#125; private Mgr02() &#123;&#125;; public static Mgr02 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr02 m1 = Mgr02.getInstance(); Mgr02 m2 = Mgr02.getInstance(); System.out.println(m1 == m2); &#125;&#125; 优点：类加载到内存后，就实例化一个单例，JVM 保证线程安全简单实用，推荐使用！ 缺点：不管用到与否，类装载时就完成实例化。如果用不上它的话，装载它会造成资源浪费。 由此我们有了另一个解决方案，那就是懒汉式： 懒汉式（Lazy Loading）第一种写法实现代码如下： 12345678910111213141516171819202122public class Mgr03 &#123; private static Mgr03 INSTANCE; private Mgr03() &#123; &#125; public static Mgr03 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr03(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 由上面代码可知，使用懒汉式之后，达到了按需初始化的目的。但是随之而来的是更严重的问题，那就是它的线程不安全问题。 就是说，两个线程如果接近同时进入 INSTANCE == null 的判断语句时，两个都会进入里面的代码块进行new对象。可知此时两个线程拿到的实例就不是同一个实例。这就是线程不安全问题。可以用以下测试代码对其进行测试： 1234567public static void main(String[] args) &#123; for(int i=0; i&lt;100; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Mgr04.getInstance().hashCode()); &#125;).start(); &#125;&#125; 为了解决线程不安全的问题，我们又进行了以下优化： 第二种写法代码如下： 12345678910111213141516171819202122public class Mgr04 &#123; private static Mgr04 INSTANCE; private Mgr04() &#123; &#125; public static synchronized Mgr04 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr04(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 我们对实例方法进行了加锁处理，保证了线程安全的问题。但是，不难想象，如果有大量的线程访问的话，那么它的效率会大幅下降。 我们再做一下优化： 123456789101112131415161718192021222324public class Mgr05 &#123; private static Mgr05 INSTANCE; private Mgr05() &#123; &#125; public static Mgr05 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Mgr05.class) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr05(); &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次我们把锁加在了实例方法里面的Mgr05.class上，妄图通过减小同步代码块的方式提高效率，测试后，不可行。 原因是，虽然对Mgr05.class进行了加锁，但是如果两个线程同时进入INSTANCE==null代码块里面，它依然会new出两个不同的实例。 现在可知，问题就处在了INSTANCE == null判断语句这块儿，那么我们针对这块儿进行优化。 第三种写法123456789101112131415161718192021222324252627public class Mgr06 &#123; private static Mgr06 INSTANCE; //JIT private Mgr06() &#123; &#125; public static Mgr06 getInstance() &#123; if (INSTANCE == null) &#123; //双重检查 synchronized (Mgr06.class) &#123; if(INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr06(); &#125; &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次优化，我们针对的就是判断实例是否为空这个点，进行了双层检查，即使两个同时进入了第一层判断，一个拿到锁之后，先实例化了一个对象，第二个再进去之后，还需要第二只判断，如果已经有了实例，那么就直接跳出，不再new新的实例。 这时可能会有个疑问，那么外层的检查还有必要存在吗？答案是当然需要，如果没有了外层的判断，每个线程都要加锁上锁，不得把JVM累死，下可能自然就变差了。 静态内部类方式代码如下： 12345678910111213141516public class Mgr07 &#123; private Mgr07() &#123; &#125; private volatile static class Mgr07Holder &#123; private final static Mgr07 INSTANCE = new Mgr07(); &#125; public static Mgr07 getInstance() &#123; return Mgr07Holder.INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这个方法算是目前来说比较完美的一种写法。JVM保证单例，加载外部类时不会加载内部类，这样可以即可以实现懒加载，还能保证线程安全。 注意使用volatile修饰单例对象，目的是保证多线程环境下的线程安全。 枚举类方法代码如下： 1public enum Mgr08 &#123; INSTANCE; public void m() &#123;&#125;&#125; 这是《Java Effective》这本书中的一种写法，写法简单，还能保证线程同步问题，还可以防止反序列化(通俗点说就是防止反射对其造成的破坏)。中功能上来说是所有单例模式写法中最完美的。但是个人不推荐这种写法，比较别扭，不够优雅。 设计模式是一种生产技巧和模式，没有必要像孔乙己一样研究茴字有几种写法，以实际开发的场景的选择不同的写法。","categories":[],"tags":[]},{"title":"对象已死吗","slug":"对象已死吗","date":"2021-05-22T05:02:30.000Z","updated":"2021-05-22T07:02:03.431Z","comments":true,"path":"2021/05/22/对象已死吗/","link":"","permalink":"http://example.com/2021/05/22/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97/","excerpt":"","text":"对象已死吗？Java Heap中存放着几乎所有的对象实例，垃圾回收前，最重要的事就是判断是对象是否存活（还在被引用的对象）。 1. 引用计数法给对象添加一个引用计数器,每一个地方引用它,计数器值就加1，对象引用失效的时候,计数器就减1.计数器值为0的时候,此对象为垃圾。 优点：判定效率高 缺点:如果对象间循环依赖,此算法无法正确判断是否为垃圾对象。因此主流虚拟机都没有用这种算法。 循环依赖如下图所示： 2. 可达性分析算法目前主流的JVM都是用的可达性分析算法来判断对象是否存货的。 实现方法GC Roots的对象作为起始点从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain)当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达的。如下图： 图中黄色的对象仍然存活，灰色的显然是不可达的，即为可回收的对象。 可作为GC Root对象的包括 栈帧中本地变量表中引用的对象 方法区类静态属性引用的对象 方法区中常量引用的对象 方法栈JNI引用的对象 关于引用（强软弱虚）强引用：类似于Object obj = new Object()这种的就属于强引用，只要强引用存在，就永远不会被回收。 软引用：有用，但是非必须的对象。对于这些软引用关联的对象，在要发生内存异常前，将会把他们列到回收范围中进行GC，如果内存依然不够，才会报内存溢出异常。 弱引用：非必须对象，被若引用关联的对象只能生存到下一次GC发生之前。当开始GC时，无论内存是否够用，都会回收。 虚引用：最弱的一种引用关系，一个对象是否有虚引用，完全不影响其生存时间，，也无法通过虚引用来取得一个对象实例。为对象设置虚引用的唯一目的就是能在这个对象被回收时，收到一个系统通知。 3. 不可达对象是否死亡判断当对象不可达GC Roots时，将会对其进行第一次筛选，如果其未覆盖finalize()方法或者已经调用过一次finalize()方法的话，讲直接将其回收。否则，将会给其一个逃脱死亡命运的机会，并对其标记。如果到第二次GC时，它还没有被引用的话，那将会被直接回收。 4. Method Area的回收此区域的垃圾回收效率较低。 一般回收两部分内容，即：废弃常量和无用的类。 废弃常量：如果无任何地方引用此常量，那么它讲在下一次GC时被回收。 无用的类：需要同时达到以下三个条件: 该类所有实例都被回收 加载该类的ClassLoader被回收 该类对应的class对象没有被引用,无法在任何地方反射访问该类方法","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-22T04:48:48.914Z","updated":"2021-05-22T04:48:48.914Z","comments":true,"path":"2021/05/22/hello-world/","link":"","permalink":"http://example.com/2021/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"SpringBoot自定义异常视图","slug":"SpringBoot自定义异常视图","date":"2021-05-21T07:24:52.000Z","updated":"2021-05-22T07:25:02.226Z","comments":true,"path":"2021/05/21/SpringBoot自定义异常视图/","link":"","permalink":"http://example.com/2021/05/21/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%A7%86%E5%9B%BE/","excerpt":"","text":"SpringBoot自定义异常视图一、异常视图原理源码阅读DefualtErrorViewResolver.java 12345678private static final Map&lt;Series, String&gt; SERIES_VIEWS;static &#123; Map&lt;Series, String&gt; views = new EnumMap&lt;&gt;(Series.class); views.put(Series.CLIENT_ERROR, &quot;4xx&quot;); views.put(Series.SERVER_ERROR, &quot;5xx&quot;); SERIES_VIEWS = Collections.unmodifiableMap(views);&#125; 1234567891011121314151617/*** @param request* @param status 状态码* @param model map集合，存放异常信息* @return ModelAndView*/@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //去拿相应的ModelAndView。如果有相应的异常页面文件(文件名为具体状态码的文件)，否则拿到对象为null ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); //如果没有相应的异常页面文件(文件名为具体状态码的文件)，且状态码属于4xx、5xx的，进行如下处理 if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; //如果有相应的异常页面文件(SERIES_VIEWS)，否则拿到对象为null modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125; 123456789101112131415161718/*** * @param viewName 视图名* @param model map集合，存放异常信息* @return ModelAndView*/private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //给视图名加个上“error/” String errorViewName = &quot;error/&quot; + viewName; //查看是否有模板提供者 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,this.applicationContext); //如果有的话，直接按照动态的处理方式返回ModelAndView对象 if (provider != null) &#123; return new ModelAndView(errorViewName, model); &#125; //如果没有，进行静态资源的处理 return resolveResource(errorViewName, model);&#125; 1234567891011121314151617181920212223242526/*** * @param viewName 视图名* @param model map集合，存放异常信息* @return ModelAndView*/private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; //遍历静态资源路径 for (String location : this.resources.getStaticLocations()) &#123; try &#123; //拿到静态资源对象 Resource resource = this.applicationContext.getResource(location); //确定该资源是否以物理形式存在 resource = resource.createRelative(viewName + &quot;.html&quot;); if (resource.exists()) &#123; //若存在，返回ModelAndView return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; //否则，返回null return null;&#125; 流程图如下 二、实现自定义自定义自己的异常视图也是重写resolveErrorView() 函数。不过不需要再写这个麻烦的判断，直接返回一个ModelAndview带视图名和错误信息。 MyErrorViewResolver.java:123456789101112131415161718192021/** * @program: MyErrorViewResolver * @description: 自定义异常视图 * @author: yangxun199807@163.com * @create: 2020-12-13 21:07 */@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver &#123; public MyErrorViewResolver(ApplicationContext applicationContext, WebProperties.Resources resources) &#123; super(applicationContext, resources); &#125; @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;yang&quot;); mv.addAllObjects(model); return mv; &#125;&#125; yang.html:12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ERROR&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Yang.html&lt;/h2&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;exception&lt;/td&gt; &lt;td th:text=&quot;$&#123;exception&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果","categories":[],"tags":[]},{"title":"Java常用集合","slug":"Java常用集合","date":"2021-05-21T07:17:56.000Z","updated":"2021-05-22T07:21:16.681Z","comments":true,"path":"2021/05/21/Java常用集合/","link":"","permalink":"http://example.com/2021/05/21/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/","excerpt":"","text":"java常用集合集合1. Java集合分类Java常用集合主要分为Collection和Map两大类： Collection：是单列集合的顶层父类，是一个独立元素的序列，这些个元素都服从一条或者多条规则。List必须按照插入的顺序保存元素，而Set不能有重复的元素。即Collection分为List和Set两大分支。 (1) List集合是一个有序的队列，每一个元素都有他的索引。第一个元素的索引值为0。 ` List的实现类有LinkedList、ArrayList、Vector、Stack。 (2) Set集合是一个不允许有重复元素的集合。 ​ Set的实现类有HashSet、TreeSet。HashSet依赖于HashMap，他实际上是通过HashMap实现的；TreeSet依赖 于TreeMap，他实际是通过TreeMap实现的。 Map：是双列集合的顶层父类接口，是一个映射接口，即key-Value键值对。允许使用键来查找对应的值，从某种意义上来说，他将数字和对象关联在一起。Map中的每一个元素包含”key”和”key对应的value”。 (1) AbstractMap是一个抽象类，它实现了Map接口中的大部分API。二HashMap、TreeMap、WeakHashMap都是继承了AbstractMap。Hashtable虽然继承与Dictionary，但是他实现了Map接口。 2. 关于集合类(Collection) Collection是集合的父类，但是JDK不提供直接继承自Collection的集合类让用户使用，而是提供继承自Collection子接口List和Set的集合类让用户使用。 List和Set的区别，List提供了随机访问的方法，内部元素是有序的，并且允许为空；而实现Set接口的类，内部元素是无序的，并且最多只能有一个null元素，并且放入Set中的元素必须不相等，就是要满足e1.equals(e2)==false，另外必须小心操作可变对象，当Set中的可变对象被操作后使得Set中有两个元素满足了e1.equals(e2)==true时就会发生一些问题。 ArrayList类。ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 LikedList。它内部的结构是基于链表的。LinkedList实现了List接口，允许null元素。此外LinkedList实现了Deque, Queue接口，提供额外的get，remove，insert方法在LinkedList的首部或尾部。所以LinkedList可以用来实现队列操作。它也是非同步的。 Vector。它与ArrayList非常相似，但是Vector是同步的。 HashSet。它内部是使用Hash表来存放元素的，通过HashMap来实现的。元素 3. 关于容器类(Map) 容器的父接口是Map，它提供了键值对的数据结构。 HashMap。跟HashSet相似，它也是基于Hash函数的，所以作为HashMap的键值的类，必须重写hash和equals方法。它是非同步的，允许null的key和null的value。 Hashtable。它也是实现Map的一个子类，它跟HashMap非常相似，但是Hashtable是同步的，并且不允许有null的key和null的value。 TreeMap。内部结构是基于红黑树的，内部的键值集合是有序的，可以进行基于有序的相关操作，其他操作跟HashMap相似。 WeakHashMap。该类与HashMap相似，只是它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 4. 关于Collections类这是一个工具类，它的静态方法一般用来处理集合容器类，或者用来生产集合容器类。Collections.synchronizedXXX()方法可以从非同步的集合容器类获得同步的集合容器类。 5. 关于Arrays类Arrays类提供了很多处理数组相关的静态方法，如数组的查找、比较、排序等操作。另外该类还提供了一个静态方法，将数组转换成List，该方法就是 1Arrays.asList(T ... array); 6. 同步的集合类以及容器类（Synchronized）一般的集合类和容器类都是非同步的（除了Vector和Hashtable以及它们的子类），如果用在多线程环境下必须自己写有关同步的代码。JDK中为我们提供了与一般集合容器类相应的同步类，SynchronizedCollection、SynchronizedList、SynchronizedMap、SynchronizedSet、SynchronizedSortedSet、SynchronizedMap，这些类都是Collections类中的静态内部类，通过Collections.synchronizedXXX()方法就可以获得相关的同步集合容器类，并且得到的同步类与作为参数的非同步类共享数据空间，当在同步类中对集合或者容器做出修改，在非同步的类中能同步感受到。例如 12345List&lt; String&gt; list = new LinkedList&lt;&gt;();list.add(&quot;one&quot;);List&lt;String&gt; list1 = Collections.synchronizedList(list);list1.remove(0);System.out.println(list.size()); 上述代码输出结果为0 7. 并发的集合类以及容器类 同步集合或容器中，基本上在内部是使用synchronized来实现的，而且一个类中所有的方法使用的是同一个锁对象，在很多这会造成性能上的问题。另外，有一些复合操作，需要保持原子性，如获取最后一个元素（代码见下面），而同步类这时候就做不到了，所以这时候要考虑使用并发类了，并发类位于java.util.concurrent中。 1234567/***获取最后一个元素*/public static Object getLast(Vector list) &#123; int lastIndex = list.size() - 1; return list.get(lastIndex); &#125; 并发容器有ConcurrentHashMap，它采用更细粒度的锁，被称为分段锁，允许一定数量的线程并发的修改它，能够提供高并发的性能。 还有一些有用的适用于某些并发场合的集合类，CopyOnWriteArrayList等。 在这里只要Java中存在同步集合容器和并发集合容器类就可以了，当遇到多线程的情况或者要求并发的情况下，再去找相关的合适的同步或并发的集合容器类。 8. UML图","categories":[],"tags":[]}],"categories":[],"tags":[]}