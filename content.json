{"meta":{"title":"LittleY'Blog","subtitle":"","description":"","author":"LittleY","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-05-22T11:37:07.000Z","updated":"2021-05-22T09:18:11.167Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"about","date":"2021-05-22T11:37:07.000Z","updated":"2021-05-22T09:12:11.354Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-22T09:28:11.000Z","updated":"2021-05-22T09:28:23.837Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-22T09:27:31.000Z","updated":"2021-05-22T09:27:44.187Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-22T09:14:04.000Z","updated":"2021-05-22T09:14:13.631Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-05-22T09:13:07.000Z","updated":"2021-05-22T09:13:30.779Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL总体概述","slug":"MySQL总体概述","date":"2021-05-22T07:38:35.000Z","updated":"2021-05-22T09:50:47.102Z","comments":true,"path":"2021/05/22/mysql-zong-ti-gai-shu/","link":"","permalink":"http://example.com/2021/05/22/mysql-zong-ti-gai-shu/","excerpt":"","text":"MySQL架构方面Mysql的基本架构图 连接器 连接器负责跟客户端建立连接，获取权限、维持和管理连接 用户名密码验证 查询权限信息，分配对应的权限 可以使用show processlist查看现在的连接 如果太长时间没有动静，就会自动断开，通过wait_timeout控制，默认8小时 连接可以分为两类： 长连接：推荐使用，但是要周期性的断开长连接 短链接： 查询缓存当执行查询语句的时候，会先去查询缓存中查看结果，之前执行过的sql语句及其结果可能以key-value的形式存储在缓存中，如果能找到则直接返回，如果找不到，就继续执行后续的阶段。 但是，不推荐使用查询缓存： 查询缓存的失效比较频繁，只要表更新，缓存就会清空 缓存对应新更新的数据命中率比较低 分析器 词法分析：Mysql需要把输入的字符串进行识别每个部分代表什么意思 把字符串 T 识别成 表名 T 把字符串 ID 识别成 列ID 语法分析： 根据语法规则判断这个sql语句是否满足mysql的语法，如果不符合就会报错“You have an error in your SQL synta” 优化器 在具体执行SQL语句之前，要先经过优化器的处理 当表中有多个索引的时候，决定用哪个索引 当sql语句需要做多表关联的时候，决定表的连接顺序 等等 不同的执行方式对SQL语句的执行效率影响很大 RBO:基于规则的优化 CBO:基于成本的优化 Redo LogRedoLog为innodb存储引擎的日志文件 当发生数据修改的时候，innodb引擎会先将记录写到redo log中，并更新内存，此时更新就算是完成了，同时innodb引擎会在合适的时机将记录操作到磁盘中 Redolog是固定大小的，是循环写的过程 有了redolog之后，innodb就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做crash-safe FAQ：既然要避免io，为什么写redo log的时候不会造成io的问题？ Undo Log Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC) 在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态 注意：undo log是逻辑日志，可以理解为： 当delete一条记录时，undo log中会记录一条对应的insert记录 当insert一条记录时，undo log中会记录一条对应的delete记录 当update一条记录时，它记录一条对应相反的update记录 Bin logbinlog为服务端的日志文件 Binlog是server层的日志，主要做mysql功能层面的事情 与redo日志的区别: redo是innodb独有的，binlog是所有引擎都可以使用的 redo是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是这个语句的原始逻辑 redo是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前的日志信息 Binlog中会记录所有的逻辑，并且采用追加写的方式 一般在企业中数据库会有备份系统，可以定期执行备份，备份的周期可以自己设置 恢复数据的过程： 找到最近一次的全量备份数据 从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时刻 数据更新的流程执行流程： 执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回 执行器拿到数据之后会先修改数据，然后调用引擎接口重新吸入数据 引擎将数据更新到内存，同时写数据到redo中，此时处于prepare阶段，并通知执行器执行完成，随时可以操作 执行器生成这个操作的binlog 执行器调用引擎的事务提交接口，引擎把刚刚写完的redo改成commit状态，更新完成 FAQ：为什么不先写binlog再写Redo Log？ 先写redo log后写binlog: 假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。 先写binlog后写redo log: 如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[]},{"title":"MySQL执行计划","slug":"MySQL执行计划","date":"2021-05-22T07:38:00.000Z","updated":"2021-05-22T09:50:39.515Z","comments":true,"path":"2021/05/22/mysql-zhi-xing-ji-hua/","link":"","permalink":"http://example.com/2021/05/22/mysql-zhi-xing-ji-hua/","excerpt":"","text":"mysql执行计划​ 在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。 ​ 可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。 ​ 官网地址： https://dev.mysql.com/doc/refman/5.5/en/explain-output.html 执行计划中包含的信息 Column Meaning id The SELECT identifier select_type The SELECT type table The table for the output row partitions The matching partitions type The join type possible_keys The possible indexes to choose key The index actually chosen key_len The length of the chosen key ref The columns compared to the index rows Estimate of rows to be examined filtered Percentage of rows filtered by table condition extra Additional information idselect查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序 id号分为三种情况： ​ 1、如果id相同，那么执行顺序从上到下 explain select * from emp e join dept d on e.deptno = d.deptno join salgrade sg on e.sal between sg.losal and sg.hisal; ​ 2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 explain select * from emp e where e.deptno in (select d.deptno from dept d where d.dname = 'SALES'); ​ 3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行 explain select * from emp e join dept d on e.deptno = d.deptno join salgrade sg on e.sal between sg.losal and sg.hisal where e.deptno in (select d.deptno from dept d where d.dname = 'SALES'); select_type主要用来分辨查询的类型，是普通查询还是联合查询还是子查询 select_type Value Meaning SIMPLE Simple SELECT (not using UNION or subqueries) PRIMARY Outermost SELECT UNION Second or later SELECT statement in a UNION DEPENDENT UNION Second or later SELECT statement in a UNION, dependent on outer query UNION RESULT Result of a UNION. SUBQUERY First SELECT in subquery DEPENDENT SUBQUERY First SELECT in subquery, dependent on outer query DERIVED Derived table UNCACHEABLE SUBQUERY A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query UNCACHEABLE UNION The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) --sample:简单的查询，不包含子查询和union explain select * from emp; --primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary explain select staname,ename supname from (select ename staname,mgr from emp) t join emp on t.mgr=emp.empno ; --union:若第二个select出现在union之后，则被标记为union explain select * from emp where deptno = 10 union select * from emp where sal >2000; --dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响 explain select * from emp e where e.empno in ( select empno from emp where deptno = 10 union select empno from emp where sal >2000) --union result:从union表获取结果的select explain select * from emp where deptno = 10 union select * from emp where sal >2000; --subquery:在select或者where列表中包含子查询 explain select * from emp where sal > (select avg(sal) from emp) ; --dependent subquery:subquery的子查询要受到外部表查询的影响 explain select * from emp e where e.deptno in (select distinct deptno from dept); --DERIVED: from子句中出现的子查询，也叫做派生类， explain select staname,ename supname from (select ename staname,mgr from emp) t join emp on t.mgr=emp.empno ; --UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存 explain select * from emp where empno = (select empno from emp where deptno=@@sort_buffer_size); --uncacheable union:表示union的查询结果不能被缓存：sql语句未验证 table对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集 1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名 ​ 2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表 ​ 3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id typetype显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般情况下，得保证查询至少达到range级别，最好能达到ref --all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。 explain select * from emp; --index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序 explain select empno from emp; --range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;>, >, >=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() explain select * from emp where empno between 7000 and 7500; --index_subquery：利用索引来关联子查询，不再扫描全表 explain select * from emp where emp.job in (select job from t_job); --unique_subquery:该连接类型类似于index_subquery,使用的是唯一索引 explain select * from emp e where e.deptno in (select distinct deptno from dept); --index_merge：在查询过程中需要多个索引组合使用，没有模拟出来 --ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式 explain select * from emp e where e.mgr is null or e.mgr=7369; --ref：使用了非唯一性索引进行数据的查找 create index idx_3 on emp(deptno); explain select * from emp e,dept d where e.deptno =d.deptno; --eq_ref ：使用唯一性索引进行数据查找 explain select * from emp,emp2 where emp.empno = emp2.empno; --const：这个表至多有一个匹配行， explain select * from emp where empno = 7369; --system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现 possible_keys 显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用 explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10; key 实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。 explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10; key_len 表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。 explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10; ref 显示索引的哪一列被使用了，如果可能的话，是一个常数 explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10; rows 根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好 explain select * from emp; extra 包含额外的信息。 --using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置explain select * from emp order by sal;--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除explain select ename,count(*) from emp where deptno = 10 group by ename;--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找explain select deptno,count(*) from emp group by deptno limit 10;--using where:使用where进行条件过滤explain select * from t_user where id = 1;--using join buffer:使用连接缓存，情况没有模拟出来--impossible where：where语句的结果总是falseexplain select * from emp where empno = 7469;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[]},{"title":"MySQL锁机制","slug":"MySQL锁机制","date":"2021-05-22T07:37:39.000Z","updated":"2021-05-22T09:50:32.763Z","comments":true,"path":"2021/05/22/mysql-suo-ji-zhi/","link":"","permalink":"http://example.com/2021/05/22/mysql-suo-ji-zhi/","excerpt":"","text":"mysql的锁机制1、MySQL锁的介绍​ 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 ​ 相对其他数据库而言，MySQL的锁机制比较简单，其最 显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 ​ 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。​ 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 ​ 从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。 2、MyISAM表锁MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。 对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！ MyISAM写锁阻塞读的案例： ​ 当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读和写操作都会等待，直到锁释放为止。 session1 session2 获取表的write锁定lock table mylock write; 当前session对表的查询，插入，更新操作都可以执行select * from mylock;insert into mylock values(5,’e’); 当前session对表的查询会被阻塞select * from mylock； 释放锁：unlock tables； 当前session能够立刻执行，并返回对应结果 MyISAM读阻塞写的案例： ​ 一个session使用lock table给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待。 session1 session2 获得表的read锁定lock table mylock read; 当前session可以查询该表记录：select * from mylock; 当前session可以查询该表记录：select * from mylock; 当前session不能查询没有锁定的表select * from personTable ‘person’ was not locked with LOCK TABLES 当前session可以查询或者更新未锁定的表select * from personinsert into person values(1,’zhangsan’); 当前session插入或者更新表会提示错误insert into mylock values(6,’f’)Table ‘mylock’ was locked with a READ lock and can’t be updatedupdate mylock set name=’aa’ where id = 1;Table ‘mylock’ was locked with a READ lock and can’t be updated 当前session插入数据会等待获得锁insert into mylock values(6,’f’); 释放锁unlock tables; 获得锁，更新成功 注意: MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。 MyISAM的并发插入问题 MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行 session1 session2 获取表的read lock锁定lock table mylock read local 当前session不能对表进行更新或者插入操作insert into mylock values(6,’f’)Table ‘mylock’ was locked with a READ lock and can’t be updatedupdate mylock set name=’aa’ where id = 1;Table ‘mylock’ was locked with a READ lock and can’t be updated 其他session可以查询该表的记录select* from mylock 当前session不能查询没有锁定的表select * from personTable ‘person’ was not locked with LOCK TABLES 其他session可以进行插入操作，但是更新会阻塞update mylock set name = ‘aa’ where id = 1; 当前session不能访问其他session插入的记录； 释放锁资源：unlock tables 当前session获取锁，更新操作完成 当前session可以查看其他session插入的记录 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： mysql> show status like 'table%'; +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | Table_locks_immediate | 352 | | Table_locks_waited | 2 | +-----------------------+-------+ --如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。 3、InnoDB行锁1、事务及其ACID属性 事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。 原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。UndoLog实现一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。锁实现持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。RedoLog实现 2、并发事务带来的问题 相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来一下问题： 脏读： 一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读” 不可重复读：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。 幻读： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。 数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，需要根据具体的业务需求来决定使用哪种隔离级别 脏读 不可重复读 幻读 read uncommitted √ √ √ read committed √ √ repeatable read √ serializable 补充： 未提交读（READ UNCOMMITTED）：是最低的隔离级别,在这种隔离级别下,如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。 已提交读（READ COMMITTED）：读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行,会对该写锁一直保持直到到事务提交。 可重复读（REPEATABLE READS）：是介于已提交读和可串行化之间的一种隔离级别(废话 )。具体内容点击链接 **可串行化（Serializable ）:**是高的隔离级别,它求在选定对象上的读锁和写锁保持直到事务结束后才能释放,所以能防住上诉所有问题,但因为是串行化的,所以效率较低。 已提交读 可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况： mysql> show status like 'innodb_row_lock%'; +-------------------------------+-------+ | Variable_name | Value | +-------------------------------+-------+ | Innodb_row_lock_current_waits | 0 | | Innodb_row_lock_time | 18702 | | Innodb_row_lock_time_avg | 18702 | | Innodb_row_lock_time_max | 18702 | | Innodb_row_lock_waits | 1 | +-------------------------------+-------+ --如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高 3、InnoDB的行锁模式及加锁方法 ​ 共享锁（s）：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。​ 排他锁（x）：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能对A不能读和写，再对A加任何锁，直到T释放A上的锁。 ​ mysql InnoDB引擎默认的修改数据语句：update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。 InnoDB行锁实现方式 ​ InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁 create table tab_no_index(id int,name varchar(10)) engine=innodb; insert into tab_no_index values(1,'1'),(2,'2'),(3,'3'),(4,'4'); session1 session2 set autocommit=0select * from tab_no_index where id = 1; set autocommit=0select * from tab_no_index where id =2 select * from tab_no_index where id = 1 for update select * from tab_no_index where id = 2 for update; session1只给一行加了排他锁，但是session2在请求其他行的排他锁的时候，会出现锁等待。原因是在没有索引的情况下，innodb只能使用表锁。 2、创建带索引的表进行条件查询，innodb使用的是行锁 create table tab_with_index(id int,name varchar(10)) engine=innodb; alter table tab_with_index add index id(id); insert into tab_with_index values(1,'1'),(2,'2'),(3,'3'),(4,'4'); session1 session2 set autocommit=0select * from tab_with_indexwhere id = 1; set autocommit=0select * from tab_with_indexwhere id =2 select * from tab_with_indexwhere id = 1 for update select * from tab_with_indexwhere id = 2 for update; 3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。 alter table tab_with_index drop index id; insert into tab_with_index values(1,'4'); session1 session2 set autocommit=0 set autocommit=0 select * from tab_with_index where id = 1 and name=’1’ for update select * from tab_with_index where id = 1 and name=’4’ for update虽然session2访问的是和session1不同的记录，但是因为使用了相同的索引，所以需要等待锁 总结对于MyISAM的表锁，主要讨论了以下几点： 共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。 在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。 MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。 对于InnoDB表，本文主要讨论了以下几项内容： InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。 在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括： 尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会； 选择合理的事务大小，小事务发生锁冲突的几率也更小； 给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁； 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会； 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁； 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[]},{"title":"关于MySQL一些概念","slug":"关于MySQL一些概念","date":"2021-05-22T07:36:28.000Z","updated":"2021-05-22T09:49:21.291Z","comments":true,"path":"2021/05/22/guan-yu-mysql-yi-xie-gai-nian/","link":"","permalink":"http://example.com/2021/05/22/guan-yu-mysql-yi-xie-gai-nian/","excerpt":"","text":"索引失效1、如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因) 注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 2、对于多列索引，不是使用的第一部分，则不会使用索引 3、like查询是以%开头，索引失效；以%结尾，索引有效 4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引 5、如果mysql估计使用全表扫描要比使用索引快,则不使用索引 事务 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 索引1. 普通索引 这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。 2. 唯一索引 与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。 3. 全文索引（FULLTEXT） MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。 4. 单列索引、多列索引 多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 5. 组合索引（最左前缀） 平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。 索引覆盖 解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。 解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。 解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[]},{"title":"滑动窗口","slug":"滑动窗口","date":"2021-05-22T07:35:18.000Z","updated":"2021-05-22T09:49:32.596Z","comments":true,"path":"2021/05/22/hua-dong-chuang-kou/","link":"","permalink":"http://example.com/2021/05/22/hua-dong-chuang-kou/","excerpt":"","text":"有一个大小为 kk 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 kk 个数字。每次滑动窗口向右移动一个位置。 以下是一个例子：该数组为 [1 3 -1 -3 5 3 6 7]，kk 为 33。 窗口位置 最小值 最大值 [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。 输入格式输入包含两行。第一行包含两个整数 nn 和 kk，分别代表数组长度和滑动窗口的长度。第二行有 nn 个整数，代表数组的具体数值。同行数据之间用空格隔开。 输出格式输出包含两个。第一行输出，从左至右，每个位置滑动窗口中的最小值。第二行输出，从左至右，每个位置滑动窗口中的最大值。 解题思路本题使用的是单调队列的解决方案。首先，代码中的嗯a[N]是用来存放所输入的数组，q[N]是用来模拟的单调队列的数组。其思想和单调栈解决问题的思想很相似。既然要拿到极值，则可以维护一个长度为k的单调队列，用来存放窗口内的数字。因此，每次直接取此队列的头节点即为所需数。 解题步骤 判断队头部是否出窗口； 比较当前数组和当前的队列，进行维护，使之保持单调性； 将当前的下标插到队列尾部； 输出当前队列头部节点(“即极值”)。 此外需要注意的点几点 上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素; 算最大值前注意将hh和tt重置; hh从0开始，数组下标也要从0开始。 #include &lt;iostream> using namespace std; const int N = 1000010; //a[N]：存储样本数据 //q[N]：数组模拟队列，存放的是指针（即下标） int a[N],q[N]; int main ()&#123; int n,k; scanf(\"%d%d\",&amp;n,&amp;k); for(int i = 0;i &lt; n;i ++) scanf(\"%d\",&amp;a[i]); int hh = 0, tt = -1; for(int i = 0;i &lt; n ;i ++)&#123; //若队列头部出了窗口，则头部后移一下 if(hh &lt;= tt &amp;&amp; i - k + 1 > q[hh]) hh ++ ; //如果新的节点小于队尾，则删去队尾，一直删到符合单调性位置 while(hh &lt;= tt &amp;&amp; a[q[tt]] >= a[i]) tt--; //在向队尾插入新的节点，（注意） q[++ tt] = i; //只要窗口满了，则输出结果 if(i >= k - 1) printf(\"%d \",a[q[hh]]); &#125; puts(\"\"); //求极大值同理，将上面的代码镜像一下就OK hh = 0, tt = -1; for(int i = 0;i &lt; n ;i ++)&#123; if(hh &lt;= tt &amp;&amp; i - k + 1 > q[hh]) hh ++ ; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++ tt] = i; if(i >= k - 1) printf(\"%d \",a[q[hh]]); &#125; puts(\"\"); return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"第k个数","slug":"第k个数","date":"2021-05-22T07:34:37.000Z","updated":"2021-05-22T09:48:38.630Z","comments":true,"path":"2021/05/22/di-k-ge-shu/","link":"","permalink":"http://example.com/2021/05/22/di-k-ge-shu/","excerpt":"","text":"给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。 输入格式第一行包含两个整数 n 和 k。第二行包含 n 个整数（所有整数均在1~109109范围内），表示整数数列。 输出格式输出一个整数，表示数列的第k小数。 数据范围1≤n≤1000001≤n≤100000,1≤k≤n1≤k≤n 输入样例：5 3 2 4 1 5 3 输出样例：3 代码：#include &lt;iostream> using namespace std; const int N = 100010; int n,k; int q[N]; int quick_sort(int q[],int l ,int r,int k)&#123; if (l >= r) return q[l]; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while(i &lt; j)&#123; do i ++ ; while(q[i] &lt; x); do j -- ; while(q[j] > x); if(i &lt; j) swap(q[i],q[j]); &#125; int sl = j - l + 1; if (sl >= k) return quick_sort(q, l, j, k); return quick_sort(q, j + 1, r, k - sl); &#125; int main()&#123; cin >> n >> k; for(int i = 0; i &lt; n ; i++) cin >> q[i]; cout &lt;&lt; quick_sort(q,0,n-1,k) &lt;&lt; endl; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"归并排序","slug":"归并排序","date":"2021-05-22T07:33:54.000Z","updated":"2021-05-22T09:49:27.803Z","comments":true,"path":"2021/05/22/gui-bing-pai-xu/","link":"","permalink":"http://example.com/2021/05/22/gui-bing-pai-xu/","excerpt":"","text":"归并排序分为以下几个步骤： 分割子问题 递归处理子问题 归并子问题处理结果，得到目标问题结果 #include &lt;iostream> using namespace std; const int N = 100010; int n; int q[N],temp[N]; void merge_sort(int q[],int l,int r)&#123; if(l >= r) return; int mid = (l+r)>>1; merge_sort(q,l,mid),merge_sort(q,mid+1,r); int i = l, j = mid + 1,k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r)&#123; if(q[i] &lt; q[j]) temp[k++] = q[i++]; else temp[k++] = q[j++]; &#125; while(i &lt;= mid) temp[k++] = q[i++]; while(j &lt;= r) temp[k++] = q[j++]; for(i = l, k = 0; i &lt;= r; i++,k++) q[i] = temp[k]; &#125; int main()&#123; cin>>n; for(int i = 0; i &lt; n; i++) cin>>q[i]; merge_sort(q, 0, n-1); for(int i = 0; i &lt; n; i++) cout&lt;&lt;q[i]&lt;&lt;\" \"; &#125; 具体分析待证问题: tmp 保存的是 q[l..mid] , q[mid+1..r] 中从小到大排序的所有数证明(第一个 while 循环)循环不变式: tmp[0..k-1] 保存上述俩数组中从小到大排序的最小 k 个数 初始k = 0, tmp[0..k-1] 为空，显然成立 保持假设某轮循环开始之前，循环不变式成立若 q[i] &lt;= q[j], 则 tmp[k] = q[i]其中, q[i] &lt;= q[i+1..mid], q[i] &lt;= q[j] &lt;= q[j+1..r]∴ q[i] 是剩下的所有数中最小的一个当 q[i] &gt; q[j] 时，同理可以得到 tmp[k] = q[j] 是剩下数中最小的一个∴ tmp[k] 是剩下数中最小的一个∴ k自增之后，下轮循环开始之前，tmp[0..k-1]保存从小到大排序的最小k个数 终止i &gt; mid 或 j &gt; r则 q[l..mid] 和 q[mid+1..r] 其中一个数组的数都已遍历tmp[0..k-1]保存从小到大排序的最小k个数 边界分析为什么不用 mid - 1 作为分隔线呢 即 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r)因为 mid = l + r &gt;&gt; 1 是向下取整，mid 有可能取到 l (数组只有两个数时)，造成无限划分解决办法: mid 向上取整就可以了, 即 mid = l + r + 1 &gt;&gt; 1,如下所示: void merge_sort(int q[], int l, int r) &#123; if(l >= r) return; int mid = l + r + 1>> 1;//注意mid是向上取整 merge_sort(q, l, mid - 1 ), merge_sort(q, mid, r); int k = 0, i = l, j = mid, tmp[r - l + 1]; while(i &lt; mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i &lt; mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(k = 0, i = l; i &lt;= r; k++, i++) q[i] = tmp[k]; &#125; 不过最好不要这样写,很奇葩,不对称 为什么 用 mid 作为分隔线时不会造成无限划分呢因为此时 mid 是向下取整的, merge_sort(q, l, mid ) 中的 mid 一定不会取到 r 值∴ merge_sort(q, l, mid ) 不会无限划分","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Git命令集合","slug":"Git命令集合","date":"2021-05-22T07:23:00.000Z","updated":"2021-05-22T09:49:56.064Z","comments":true,"path":"2021/05/22/git-ming-ling-ji-he/","link":"","permalink":"http://example.com/2021/05/22/git-ming-ling-ji-he/","excerpt":"","text":"Git命令集合1. 提前配置git config --global user.name USERNAME #配置用户名 git config --global user.email USEREMAIL #配置用户邮箱 2. 提交步骤git init #初始化git仓库 git status #查看文件状态 git add #添加到缓存区，追踪文件 git commit -m MESSAGE #提交信息，向仓库中提交代码 git log #查看提交记录 3. Git撤销git checkout FILENAME #用暂存区的文件覆盖工作目录中的文件 git rm --cached FILENAME #将文件从暂存区删除 git reset --hard COMMITID #将git仓库中指定的更新记录恢复出来，并覆盖暂存区和工作目录 4. Git分支git branch #查看分支 git branch 分支名称 #创建分支 git checkout 分支名称 #切换分支 git merge 来源分支 #合并分支 git branch -d 分支名称 #删除分支（分支被合并后才允许被删除） （-D代表强制删除） 5. 暂时保存更改git stash #存储临时改动 git stash pop #恢复改动 6. 推送到远程仓库git push 远程仓库地址 分支名称 #将当前分支推送到远端仓库的指定点分支中 git push 远程仓库地址别名 分支名称 git push -u 远程仓库地址别名 分支名称 # -u是记住地址及分支，下次推送直接git push即可 git remote add 远程仓库别名 远程仓库地址 #为远程仓库起别名 7. 拉取远程仓库操作git clone 远程仓库地址 #克隆远程仓库代码到本地仓库 git pull 远程仓库地址 分支名称 #获取远程仓库的最新版本 8. 解决冲突问题遇到代码冲突问题，只能人为修改以保证分支正常 9. 跨团队合作甲程序员 Fork仓库 –&gt; 甲程序员讲仓库clone到本地进行修改 –&gt; 甲程序员推送到远程 –&gt; 甲程序员发起pull request –&gt; 原作者审核 –&gt; 原作者进行合并代码 10. SSH免登陆生成秘钥：ssh-keygen 秘钥存储目录： C：&#x2F;Users&#x2F;你的用户名&#x2F;.ssh 公钥名称：id_rsa.pub 私钥名称：id_rsa 生成秘钥后，打开公钥，复制内容，在远程仓库中，Setting –&gt; SSH设置 –&gt; 添加SSH秘钥 –&gt; 粘贴添加。然后在push的时候通过ssh链接进行推送，即可实现不用账号密码登录","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"关于整数二分查找及边界问题分析","slug":"关于整数二分查找及边界问题分析","date":"2021-05-22T07:22:41.000Z","updated":"2021-05-22T09:49:04.230Z","comments":true,"path":"2021/05/22/guan-yu-zheng-shu-er-fen-cha-zhao-ji-bian-jie-wen-ti-fen-xi/","link":"","permalink":"http://example.com/2021/05/22/guan-yu-zheng-shu-er-fen-cha-zhao-ji-bian-jie-wen-ti-fen-xi/","excerpt":"","text":"关于整数二分查找及边界问题分析二分查找属于分治算法。 所谓的二分算法,就是我们知道当前的候选区间中,一定存在我们要找到的答案,而且我们发现这个区间拥有单调性质此类的性质,那么我们可以不停地缩减候选区间的范围,达到排除无用答案的效果. 算法模板寻找右分界点int bsearch_1(int l, int r) &#123; &#x2F;&#x2F;第二步：递归处理子问题，用while循环来实现 while (l &lt; r) &#123; &#x2F;&#x2F;第一步：分解成子问题,这是二分的核心--范围减半 int mid &#x3D; l + r &gt;&gt; 1; if (check(mid)) r &#x3D; mid; &#x2F;&#x2F;向左边找 if判断mid是否满足性质，注意该性质会划分数组的右边部分 else l &#x3D; mid + 1; &#x2F;&#x2F;向右边找 &#125; &#x2F;&#x2F;第三步：合并子问题.对二分算法来说，不需要这一步 return l; &#x2F;&#x2F;l就是寻找的右分界点,如果数组中没有要找的点，l的值就是r,但这是一个错误答案 &#125; 寻找左分界点int bsearch_2(int l, int r) &#123; while (l &lt; r) &#123; int mid &#x3D; l + r + 1 &gt;&gt; 1; &#x2F;&#x2F; mid 向上取整 if (check(mid)) l &#x3D; mid; else r &#x3D; mid - 1; &#125; return l; &#125; 证明待证问题：循环结束后的l就是要找的点(默认包含答案)循环不变式：[l..r]中包含答案点res 初始 显然[l..r]包含答案点res 保持 假设某轮循环开始之前,[l..r]包含答案点res 执行循环体 int mid = l + r &gt;&gt; 1 mid是向下取整得到的 if语句分支1： 如果mid满足性质，那么说明res在[l..mid]间(包括mid本身),令 r = mid if语句分支2： 如果 mid 不满足性质，说明mid在左边部分，res在[mid+1..r]间,令l = mid + 1 ∴ l和r更新之后，下一轮循环开始之前，循环不变式依然成立 终止 循环终止时， l &gt;= r 易知 l不可能比 r 大 , 故 l = r ∴ 根据循环不变式，l是答案点 res 边界分析问题：为什么 mid 是向下取整得到的，即 mid = l + r &gt;&gt; 1. 而不是向上取整,即 mid = l + r + 1 &gt;&gt; 1 答：mid向下取整是为了缩小范围，避免造成无限划分 证明if语句分支1： r = mid = l + r &gt;&gt; 1 (向下取整) 一定小于原来的 r if语句分支2： l = mid + 1 一定大于原来的 l 所以，mid向下取整的话，就不会造成无限划分 注：对于二分的另一种情况，即寻找左分界点, mid就需要向上取整了 案例题目描述给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。 输入格式第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~1000010000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围1≤n≤1000001≤n≤1000001≤q≤100001≤q≤100001≤k≤10000 输入样例： 6 31 2 2 3 3 4345 输出样例： 3 45 5-1 -1 审题在一个范围内,查找一个数字,要求找到这个元素的起始位置和结束位置,请注意这个范围内的数字都是单调递增的,即具有单调性质. 代码实现C++: #include &lt;iostream&gt; using namespace std; const int N &#x3D; 100010; int n, m; int q[N]; int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); while (m -- ) &#123; int target; scanf(&quot;%d&quot;,&amp;target); int l &#x3D; 0,r &#x3D; n-1; while (l &lt; r) &#123; int mid &#x3D; l + r &gt;&gt; 1; if (q[mid] &gt;&#x3D; target) r &#x3D; mid; else l &#x3D; mid + 1; &#125; if(q[l] !&#x3D; target) cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; l &lt;&lt; &#39; &#39;; int l &#x3D; 0, r &#x3D; n - 1; while (l &lt; r) &#123; int mid &#x3D; l + r + 1 &gt;&gt; 1; if (q[mid] &lt;&#x3D; target) l &#x3D; mid; else r &#x3D; mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0; &#125; Java: import java.util.*; /** * @program: BinSearch01 * @description: TODO * @author: yangxun199807@163.com * @create: 2020-11-06 12:51 */ class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); //数组长度 int q = sc.nextInt(); //询问个数 int arr[] = new int[n]; for (int i = 0; i &lt; arr.length; i++) arr[i] = sc.nextInt(); for (int i = 0; i &lt; q; i++) &#123; binSearch(arr); &#125; &#125; private static void binSearch(int[] arr) &#123; int l = 0, r = arr.length-1; Scanner sc = new Scanner(System.in); int target = sc.nextInt(); while (l &lt; r)&#123; int mid = l + r >> 1; if (target &lt;= arr[mid]) r = mid; else l = mid + 1; &#125; if (arr[l] != target)&#123; System.out.println(\"-1 -1\"); return; &#125; else &#123; System.out.print(l + \" \"); &#125; l = 0; r = arr.length-1; while (l &lt; r)&#123; int mid = l + r + 1 >> 1; if (arr[mid] &lt;= target) l = mid; else r = mid - 1; &#125; System.out.print(r); &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"JVM探究","slug":"JVM探究","date":"2021-05-22T07:10:37.000Z","updated":"2021-05-22T09:50:17.116Z","comments":true,"path":"2021/05/22/jvm-tan-jiu/","link":"","permalink":"http://example.com/2021/05/22/jvm-tan-jiu/","excerpt":"","text":"JVM探究JVM的位置在哪儿？ JVM的体系结构图 根据上图，对每个部分一次进行学习。 类加载器（ClassLoader）首先，先学习类加载到JVM的过程： 在如下几种情况下，Java虚拟机将结束生命周期： 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或者错误而异常终止 由于操作系统出现错误而导致Java虚拟机进行终止","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"JVM运行时数据区域","slug":"JVM运行时数据区域","date":"2021-05-22T07:09:26.000Z","updated":"2021-05-22T09:50:23.120Z","comments":true,"path":"2021/05/22/jvm-yun-xing-shi-shu-ju-qu-yu/","link":"","permalink":"http://example.com/2021/05/22/jvm-yun-xing-shi-shu-ju-qu-yu/","excerpt":"","text":"运行时数据区图示图中灰色区域即为运行时数据区 1. Program Counter Register（PCR）程序计数器。内存较小，是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 线程私有，各个县城之间的计数器互不影响，独立存储。 如果线程正在执行的是一个Java方法，则记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器的值为空。 至内存区域是唯一一个在JVM中没有规定任何OOM（OutOfMemoryError）情况的区域。 2. JVM Stack线程私有，生命周期与线程相同。 每个方法执行是都会创建一个栈帧（Stack Frame），栈帧包括如下： 局部变量表 存放编译器可知的8种基本数据类型以及对象引用类型(reference) 其中64位长度的long和double类型会占两个Slot，其余的只占一个 局部变量表所需内存在编译期间就一完成分配 操作数栈 动态链接 返回地址 方法出口 异常情况 StackOverFlowError OutOfMemoryError … 3. Naive Method Stack线程私有，执行的是Native方法。异常情况与JVM Stack相同。 关于Native方法: A native method is a Java method whose implementation is provided by non-java code. 意思就是Native方法就是该方法的实现是由其他语言实现，而并非Java。在Java诞生的时候，还是C和C++的天下，Java一方面为了迎合市场，一方面为了弥补Java的不足，便有了这个机制。 4. Java HeapJava Heap是JVM种占内存最大的一块。此内存区域线程共享。在虚拟机启动时创建。 此内存作用就是用来存储对象实例。因此它也是GC的重点区域。 结构Java Heap的内部还根据内存回收的角度，对其区域进行分代： 新生代 Eden区 From Survivor空间（S1区） To Survivor空间（S2区） 老年代 从内存分配的角度看，线程共享的堆中坑划分出多个线程私有的TLAB（Thread Local Allocation Buffer），即内存缓冲区。 在物理内存中，Java Heap是不连续的内存空间，只要逻辑上是连续的即可。 5. Method Area关于永久代和元空间、方法区的区别方法区属于JVM规范中的定义，而永久代是一种实现。也就是说方法区属于一个标准，而永久代是HotSpot对于这个标准的实现。在Java8之后，HotSpot进行了“去永久代”，把永久代取消，取而代之的是元空间。 而元空间和永久代的区别在于存储位置的不同，永久代在物理上是堆的一部分和新生代，老年代的存储地址是连续的，只是在逻辑上不是(当时也被称作 Non Heap Memory)；而元空间属于本地内存。还有一点就是在存储的内容不同，元空间用来准出类的元信息，而静态变量和常量池被并入到了Java Heap中。可以理解为，永久代的数据被分到了Java Heap和元空间中。 用途用于存储被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 6. Runtime Constant Pool（运行时常量池） 运行时常量池是方法区的一部分，是一块内存区域。运行时常量池将在类加载后进入方法区的运行时常量池中存放。一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。 7. Direct Memory（直接内存）一般是NIO类（New Input/Output）使用这块内存较多。 此内存区域并不属于运行时数据区，也不是JVM规范中定义的内存区域，因此，它只有可能出现OutOfMemoryError。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"内存分配与回收策略","slug":"内存分配与回收策略","date":"2021-05-22T07:08:46.000Z","updated":"2021-05-22T09:49:47.302Z","comments":true,"path":"2021/05/22/nei-cun-fen-pei-yu-hui-shou-ce-lue/","link":"","permalink":"http://example.com/2021/05/22/nei-cun-fen-pei-yu-hui-shou-ce-lue/","excerpt":"","text":"内存分配与回收策略年轻代 对象主要分配在新生代的Eden区域 启动本地线程分配缓存的话,则优先在TLAB上分配 优先将对象分配在新生代上,Eden区域内存不够时发送Minor GC 老年代 大对象直接进入老年代 长期存活的对象进入老年代 注意:可以配置参数指定大于多大对象直接进入老年代,防止年轻代内存复制频繁 当对象在Eden区域时经历了第一次Minor GC的时候,并且移动到Survivor区域时,这个时候它的年龄为1,每熬过一次Minor GC,年龄加1,当年龄达到一定程度的话(默认为15岁),那么晋升到老年代. 为了更好的适应不同程序的内存情况,虚拟机并不是完全按照对象年龄计算的。如果在Survivor空间中相同年龄的对象总和大于或者等于Survivor空间的一半时,那么等于和大于这个年龄的对象都会进入老年代。 Minor GC之前,JVM会判断老年代最大可用的内存是否大于年轻代所有对象内存总和,条件成立那么认为是安全的 如果不成立,尝试进行一次Minor GC,这个是有风险的,因为老年代剩余的内存可能不够 老年代会判断历史晋升到老年代对象的平均值是否大于老年代剩余的内存,以便于是FULL GC 来腾出更多的内存 内存担保失败的话就Full GC","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"类加载、类加载器、双亲委派","slug":"类加载、类加载器、双亲委派","date":"2021-05-22T07:08:04.000Z","updated":"2021-05-22T09:49:44.015Z","comments":true,"path":"2021/05/22/lei-jia-zai-lei-jia-zai-qi-shuang-qin-wei-pai/","link":"","permalink":"http://example.com/2021/05/22/lei-jia-zai-lei-jia-zai-qi-shuang-qin-wei-pai/","excerpt":"","text":"类加载、类加载器、双亲委派1. 类加载定义虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。类加载和连接的过程都是在运行期间完成的。 加载方式 本地编译好的class中直接加载 网络加载：java.net.URLClassLoader可以加载url指定的类 从jar、zip等等压缩文件加载类，自动解析jar文件找到class文件去加载util类 从java源代码文件动态编译成为class文件 类加载的生命周期加载（Loading）–&gt;验证（Verification）–&gt;准备（Preparation）–&gt;解析（Resolution）–&gt;初始化（Initialization）–&gt;使用（Using）–&gt;卸载（Unloading） 过程详解 加载 A. 加载阶段的工作： ​ i. 通过一个类的全限定名来获取定义此类的二进制字节流。 ​ ii. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 ​ iii. 在java堆中生成一个代表这个类的java.lang.Class对象，做为方法区这些数据的访问入口。 B. 加载阶段完成之后二进制字节流就按照虚拟机所需的格式存储在方区去中。 验证 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。 ​ a) 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 ​ b) 元数据验证：对字节码描述的信息进行语义分析，以确保其描述的信息符合java语言规范的要求。 ​ c) 字节码验证：这个阶段的主要工作是进行数据流和控制流的分析。任务是确保被验证类的方法在运行时不会做出危害虚拟机安全的行为。 ​ d) 符号引用验证：这一阶段发生在虚拟机将符号引用转换为直接引用的时候（解析阶段），主要是对类自身以外的信息进行匹配性的校验。目的是确保解析动作能够正常执行。 准备 准备阶段是正式为变量分配内存并设置初始值，这些内存都将在方法区中进行分配，这里的变量仅包括类标量不包括实例变量。 注意：这里的初始值不能弄混，比如说，int i = 666 在这个步骤的赋初始值是给i赋了0值，而非666。 解析 解析是虚拟机将常量池的符号引用替换为直接引用的过程。 a) 类或接口的解析 b) 字段的解析 c) 类方法解析 d) 接口方法解析 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接饮用是与内存布局相关的。 初始化 是根据程序员制定的主观计划区初始化变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器()方法的过程。（参考3中，此时的初始化才是给i赋666值的阶段） 2. 类加载器JVM中定义的有3中类加载器。分别是：启动（Bootstrap）类加载器、标准扩展（Extension）类加载器、应用类(App)加载器。 启动（Bootstrap）类加载器c++编写，加载java核心库 java.*,构造ExtClassLoader和AppClassLoader。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作 标准扩展（Extension）类加载器扩展类加载器是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader） 实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 应用（App）类加载器应用类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。 CustomClassLoader（用户自定义类加载器）java编写,用户自定义的类加载器,可加载指定路径的class文件 3. 双亲委派机制上源码protected Class&lt;?> loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 首先检查这个classsh是否已经加载过了 Class&lt;?> c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // c==null表示没有加载，如果有父类的加载器则让父类加载器加载 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; //如果父类的加载器为空 则说明递归到bootStrapClassloader了 //bootStrapClassloader比较特殊无法通过get获取 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123;&#125; if (c == null) &#123; //如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class long t1 = System.nanoTime(); c = findClass(name); sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 双亲委派是什么俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和标准扩展类加载器为例作简单分析。 类加载器模型图","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"垃圾回收算法","slug":"垃圾回收算法","date":"2021-05-22T07:06:28.000Z","updated":"2021-05-22T09:49:39.988Z","comments":true,"path":"2021/05/22/la-ji-hui-shou-suan-fa/","link":"","permalink":"http://example.com/2021/05/22/la-ji-hui-shou-suan-fa/","excerpt":"","text":"垃圾回收算算法1. Mark-Sweep（标记-清除算法）首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 缺点：标记和清除过程的效率都不高;还容易产生大量不连续的内存碎片 步骤图示： 2. Coping（复制算法）内存按容量划分为大小相等的两块，一块内存用完了,将存活着的对象复制到另外一块将都是垃圾对象的那块清空内存。 优点：速度贼快，无空间碎片 缺点：在对象存活率较高时，复制操作次数多，效率降低；內存缩小了一半;需要額外空间做分配担保(老年代) 步骤图示： 3. Mark-Compact（标记-整理法）标记步骤和标记清除算法相同，标记完后垃圾对象移动到一端,然后在清理掉。 缺点：很明显，效率很低 步骤图示： 4. Generational Collection（分代收集算法）根据以上三种方法可知，每种都有自己的有点和缺点。因此没有最好的算法，只有最合适的算法，因此我们在朝生夕死的新生代，使用效率较高的Coping算法，在CG不是特别频繁，且需要用来做Handle Promotion（空间担保）的老年区使用Mark-Compact算法或者Mark-Sweep算法。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"策略模式(Stratagy)","slug":"策略模式","date":"2021-05-22T06:45:30.000Z","updated":"2021-05-22T09:46:33.652Z","comments":true,"path":"2021/05/22/ce-lue-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/ce-lue-mo-shi/","excerpt":"","text":"策略模式(Stratagy)定义策略模式 定义一系列算法，把他们独立封装起来，并且这些算法之间可以相互替换。策略模式主要是管理一堆有共性的算法，策略模式让算法独立于使用它的客户而变化，客户端可以根据需要，很快切换这些算法，并且保持可扩展性。 比如说，我有一个排序方法，但是这个排序的规则有好几种，比如说，针对一个实体类的id进行排序，也可以针对实体类的age进行排序等等还多中规则，这些规则我都是可以随时替换的。而策略模式就是来处理这一类问题。 优缺点优点： 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点： ​ 策略模式造成很多的策略类。 原理策略模式的原理图如下： Strategy类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法。 Concrete Strategy类：实现了抽象策略定义的接口，也就是真正干活的类 Context类：持有一个策略类的引用，最终给客户端调用 注意：Context也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 举个例子此时要开发一款软件，可以使用Java，也可以使用PHP，这两个语言属于两个策略。现在使用策略模式来实现这个问题。 抽象语言类 public interface CodeLanguage &#123; void useLanguage(); &#125; 具体语言类 public class CodeJava implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(\"使用Java语言编程\"); &#125; &#125; public class CodePhp implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(\"使用Php语言编程\"); &#125; &#125; 策略引用类 public class CodeContext &#123; CodeLanguage codeLanguage; public CodeContext1(CodeLanguage codeLanguage) &#123; this.codeLanguage = codeLanguage; &#125; void useLanguage()&#123; codeLanguage.useLanguage(); &#125; &#125; 使用模式 public class Application &#123; public static void main(String[] args) &#123; CodeContext context; context = new CodeContext(new CodeJava()); context.useLanguage(); context = new CodeContext(new CodePhp()); context.useLanguage(); &#125; &#125; 此时，这个模型就已经用代码表示出来了，此时我们也不难发现，如果现在需要再增加一种策略的话，只需要新建一个CodeLanguage的实现类就可以了，在使用的时候可以直接调用策略。体现了它的扩展性","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"动态代理（Dynamic Proxy）","slug":"动态代理","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:47:04.821Z","comments":true,"path":"2021/05/22/dong-tai-dai-li/","link":"","permalink":"http://example.com/2021/05/22/dong-tai-dai-li/","excerpt":"","text":"动态代理（Dynamic Proxy）1.定义原理和静态代理相同，只是为了解决静态代理的缺点。详情请点静态代理 2. 优缺点优点除了静态代理的优点外，还解决了静态代理的短板，可以动态生成代理类，大大减少了代码量。 缺点由于用的是反射的原理，性能相对较低。 3. 步骤角色： 接口类 实现类：被代理的类 代理类：必须实现InvocationHandler接口 4. 代码为了更加形象地理解JDK动态代理的使用流程，举个栗子。 今天，小黑要和王美丽去相亲，但是由于王美丽和小黑是第一次见面，小黑不好意思直接去找她的家人邀请她去约会和看电影。先看代码： Girl接口和王美丽的实体类： package com.yang.proxy.demo2; /** * @program: Girl * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:47 */ public interface Girl &#123; public void date(); public void watchMovie(); &#125; package com.yang.proxy.demo2; /** * @program: WangMeiLi * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:46 */ public class WangMeiLi implements Girl &#123; public void date() &#123; System.out.println(\"王美丽：长得好看就行\"); &#125; public void watchMovie() &#123; System.out.println(\"王美丽：和你看电影很开心\"); &#125; &#125; 代理类： package com.yang.proxy.demo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * @program: MyProxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:55 */ public class MyProxy implements InvocationHandler &#123; private Object target; public MyProxy(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Dad(); Object invoke = method.invoke(target, args); Mom(); return invoke; &#125; public Object getInstance()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; public void Dad()&#123; System.out.println(\"对你好不好?\"); &#125; public void Mom()&#123; System.out.println(\"有房吗？有车吗？\"); &#125; &#125; 小黑通过王美丽的家人去约她，王美丽的动作很单纯，值管看电影和看人家小黑好不好看。但是她的家人（代理类）可不放心，她的家人还要在invoke()方法里进行方法增强，比图说，她爸爸要看小黑对她好不好，她妈妈要看小黑有没有房和车。增强后才放心地用getInstance()方法让女儿去和小黑约会。 现在使用测试类进行测试： package com.yang.proxy.demo2; /** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */ public class Demo &#123; public static void main(String[] args) &#123; WangMeiLi wangMeiLi = new WangMeiLi(); XiaoHei xiaoHei = new XiaoHei(); MyProxy families = new MyProxy(wangMeiLi); Girl wmother = (Girl) families.getInstance(); wmother.date(); wmother.watchMovie(); &#125; &#125; 结果如下： 对你好不好?王美丽：长得好看就行有房吗？有车吗？对你好不好?王美丽：和你看电影很开心有房吗？有车吗？ 此时，基础的代理功能已经达到了，但是还没有测试动态这个特点。因此我们现在创建一个Boy接口和小黑的类。 package com.yang.proxy.demo2; public interface Boy &#123; public void date(); public void watchMovie(); &#125; package com.yang.proxy.demo2; /** * @program: XiaoHei * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 20:39 */ public class XiaoHei implements Boy &#123; public void date() &#123; System.out.println(\"好看就行\"); &#125; public void watchMovie() &#123; System.out.println(\"电影不好看\"); &#125; &#125; 现在我们没有为小黑做任何的代理类，现在我们用这个动态代理类进行测试： package com.yang.proxy.demo2; /** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */ public class Demo &#123; public static void main(String[] args) &#123; XiaoHei xiaoHei = new XiaoHei(); MyProxy heiFamilies = new MyProxy(xiaoHei); Boy hMother = (Boy) heiFamilies.getInstance(); hMother.date(); hMother.watchMovie(); &#125; &#125; 结果如下： 对你好不好?小黑:好看就行有房吗？有车吗？对你好不好?小黑:电影不好看有房吗？有车吗？ 可见，测试成功！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"垃圾回收器","slug":"垃圾回收器","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:49:38.206Z","comments":true,"path":"2021/05/22/la-ji-hui-shou-qi/","link":"","permalink":"http://example.com/2021/05/22/la-ji-hui-shou-qi/","excerpt":"","text":"垃圾回收器1. 常见的垃圾回收器新生代收集器： Serial ParNew Parallel Scavenge 老年代回收器： Serial Old CMS Parallel Old 堆内存垃圾收集器： G1 他们之间的关系如下图： 如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。 2. 新生代垃圾收集器Serial 收集器Serial 是一款用于新生代的单线程收集器，采用复制算法进行垃圾收集。Serial 进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World）。如图： 当用户线程都执行到安全点时，所有线程暂停执行，Serial 收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行。 优点：简单高效，由于采用的是单线程的方法，因此与其他类型的收集器相比，对单个cpu来说没有了上下文之间的的切换，效率比较高。 缺点：会在用户不知道的情况下停止所有工作线程，用户体验感极差，令人难以接受。 适用场景：Client 模式（桌面应用）；单核服务器。 设置参数：可以用 -XX:+UserSerialGC 来选择 Serial 作为新生代收集器。 ParNew 收集器ParNew 就是一个 Serial 的多线程版本，其它与Serial并无区别。ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果，它默认开启的收集线程数和 CPU 数量一致，可以通过 -XX:ParallelGCThreads 来设置垃圾收集的线程数。如图： 优点：随着cpu的有效利用，对于GC时系统资源的有效利用有好处。 适用场景：ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器。因为CMS收集器只能与serial或者parNew联合使用，在当下多核系统环境下，首选的是parNew与CMS配合。ParNew收集器也是使用CMS收集器后默认的新生代收集器。 参数：可以用 -XX:UseParNewGC来选择新生代采用ParNew收集器 关于Parralel（并行）和Concurrent（并发） Parralel（并行）：指多条垃圾收集线程并行工作、但此时用户线程仍然处于等待状态 Concurrent（并发）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，也可能是交替执行的），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。 Parallel Scavenge 收集器Parallel Scavenge 也是一款用于新生代的多线程收集器，与 ParNew 的不同之处是ParNew 的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge 的目标是达到一个可控制的吞吐量。 例如虚拟机一共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那吞吐量就是 99% 。比如下面两个场景，垃圾收集器每 100 秒收集一次，每次停顿 10 秒，和垃圾收集器每 50 秒收集一次，每次停顿时间 7 秒，虽然后者每次停顿时间变短了，但是总体吞吐量变低了，CPU 总体利用率变低了。其与Parallel Old收集器运行示意图如下 适用场景：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互。 参数： XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间 XX:GCRatio 直接设置吞吐量的大小。 3. 老年代垃圾收集器Serial Old 收集器Serial Old 收集器是 Serial 的老年代版本，同样是一个单线程收集器，采用标记-整理算法。如图： 适用场景：Client 模式（桌面应用）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案。 Parallel Old 收集器是Parallel Scavenge收集器的老年代版本。如图： 适用场景：与Parallel Scavenge 收集器搭配使用；注重吞吐量。 参数：使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器。 CMS(Concurrent Mark Sweep) 收集器CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤： 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快。 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长。 重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短。 并发清除：用标记-清除算法清除垃圾对象，耗时较长。 整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的。如图： 优点： 并发收集、低停顿 缺点: 对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小 无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。 因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC. 适用场景：重视服务器响应速度，要求系统停顿时间最短。 参数：可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器 4. 新生代和老年代垃圾收集器G1 收集器一款面向服务端应用的垃圾收集器。G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region，如下图： 每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M。 为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。 G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。 如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似： 步骤： 初始标记：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。 并发标记：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。 最终标记：修正在并发标记阶段引用户程序执行而产生变动的标记记录。 筛选回收：筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。 适用场景：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"单例模式(Singleton Pattern)","slug":"单例模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:46:59.429Z","comments":true,"path":"2021/05/22/dan-li-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/dan-li-mo-shi/","excerpt":"","text":"单例模式在有些开发场景中，没有必要有多个实例存在，以节省资源。比如说 PropertiyMgr 工具类 饿汉式实现代码如下： public class Mgr01 &#123; private static final Mgr01 INSTANCE = new Mgr01(); private Mgr01() &#123;&#125;; public static Mgr01 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; public static void main(String[] args) &#123; Mgr01 m1 = Mgr01.getInstance(); Mgr01 m2 = Mgr01.getInstance(); System.out.println(m1 == m2); &#125; &#125; 还有一种写法，和上面的写法效果一模一样： public class Mgr02 &#123; private static final Mgr02 INSTANCE; static &#123; INSTANCE = new Mgr02(); &#125; private Mgr02() &#123;&#125;; public static Mgr02 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; public static void main(String[] args) &#123; Mgr02 m1 = Mgr02.getInstance(); Mgr02 m2 = Mgr02.getInstance(); System.out.println(m1 == m2); &#125; &#125; 优点：类加载到内存后，就实例化一个单例，JVM 保证线程安全简单实用，推荐使用！ 缺点：不管用到与否，类装载时就完成实例化。如果用不上它的话，装载它会造成资源浪费。 由此我们有了另一个解决方案，那就是懒汉式： 懒汉式（Lazy Loading）第一种写法实现代码如下： public class Mgr03 &#123; private static Mgr03 INSTANCE; private Mgr03() &#123; &#125; public static Mgr03 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr03(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; &#125; 由上面代码可知，使用懒汉式之后，达到了按需初始化的目的。但是随之而来的是更严重的问题，那就是它的线程不安全问题。 就是说，两个线程如果接近同时进入 INSTANCE == null 的判断语句时，两个都会进入里面的代码块进行new对象。可知此时两个线程拿到的实例就不是同一个实例。这就是线程不安全问题。可以用以下测试代码对其进行测试： public static void main(String[] args) &#123; for(int i=0; i&lt;100; i++) &#123; new Thread(()->&#123; System.out.println(Mgr04.getInstance().hashCode()); &#125;).start(); &#125; &#125; 为了解决线程不安全的问题，我们又进行了以下优化： 第二种写法代码如下： public class Mgr04 &#123; private static Mgr04 INSTANCE; private Mgr04() &#123; &#125; public static synchronized Mgr04 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr04(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; &#125; 我们对实例方法进行了加锁处理，保证了线程安全的问题。但是，不难想象，如果有大量的线程访问的话，那么它的效率会大幅下降。 我们再做一下优化： public class Mgr05 &#123; private static Mgr05 INSTANCE; private Mgr05() &#123; &#125; public static Mgr05 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Mgr05.class) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr05(); &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; &#125; 这次我们把锁加在了实例方法里面的Mgr05.class上，妄图通过减小同步代码块的方式提高效率，测试后，不可行。 原因是，虽然对Mgr05.class进行了加锁，但是如果两个线程同时进入INSTANCE==null代码块里面，它依然会new出两个不同的实例。 现在可知，问题就处在了INSTANCE == null判断语句这块儿，那么我们针对这块儿进行优化。 第三种写法public class Mgr06 &#123; private static Mgr06 INSTANCE; //JIT private Mgr06() &#123; &#125; public static Mgr06 getInstance() &#123; if (INSTANCE == null) &#123; //双重检查 synchronized (Mgr06.class) &#123; if(INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr06(); &#125; &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; &#125; 这次优化，我们针对的就是判断实例是否为空这个点，进行了双层检查，即使两个同时进入了第一层判断，一个拿到锁之后，先实例化了一个对象，第二个再进去之后，还需要第二只判断，如果已经有了实例，那么就直接跳出，不再new新的实例。 这时可能会有个疑问，那么外层的检查还有必要存在吗？答案是当然需要，如果没有了外层的判断，每个线程都要加锁上锁，不得把JVM累死，下可能自然就变差了。 静态内部类方式代码如下： public class Mgr07 &#123; private Mgr07() &#123; &#125; private volatile static class Mgr07Holder &#123; private final static Mgr07 INSTANCE = new Mgr07(); &#125; public static Mgr07 getInstance() &#123; return Mgr07Holder.INSTANCE; &#125; public void m() &#123; System.out.println(\"m\"); &#125; &#125; 这个方法算是目前来说比较完美的一种写法。JVM保证单例，加载外部类时不会加载内部类，这样可以即可以实现懒加载，还能保证线程安全。 注意使用volatile修饰单例对象，目的是保证多线程环境下的线程安全。 枚举类方法代码如下： public enum Mgr08 &#123; INSTANCE; public void m() &#123;&#125;&#125; 这是《Java Effective》这本书中的一种写法，写法简单，还能保证线程同步问题，还可以防止反序列化(通俗点说就是防止反射对其造成的破坏)。中功能上来说是所有单例模式写法中最完美的。但是个人不推荐这种写法，比较别扭，不够优雅。 设计模式是一种生产技巧和模式，没有必要像孔乙己一样研究茴字有几种写法，以实际开发的场景的选择不同的写法。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"工厂模式（Factory Pattern）","slug":"工厂模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:47:11.067Z","comments":true,"path":"2021/05/22/gong-han-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/gong-han-mo-shi/","excerpt":"","text":"工厂模式工厂设计模式，就是用来生产对象的，在Java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则，如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦 一共有3中工厂设计模式：简单工厂、工厂方法、抽象工厂 简单工厂设计模式一个工厂方法，依据传入的参数，生成对应的产品对象。 共有3个角色：抽象产品、局具体产品、具体工厂 代码实现水果接口： public interface Fruit &#123; void whatIm(); &#125; 具体类： public class Apple implements Fruit &#123; @Override public void whatIm() &#123; //苹果 &#125; &#125; public class Pear implements Fruit &#123; @Override public void whatIm() &#123; //梨 &#125; &#125; 具体工厂： public class FruitFactory &#123; public Fruit createFruit(String type) &#123; if (type.equals(\"apple\")) &#123;//生产苹果 return new Apple(); &#125; else if (type.equals(\"pear\")) &#123;//生产梨 return new Pear(); &#125; return null; &#125; &#125; 使用产品： FruitFactory mFactory = new FruitFactory(); Apple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果 Pear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨 缺点这个设计模式的缺点显而易见，当我需要添加一种水果的时候，我不但需要新建一个水果的类，还需要修改工厂类。违反了开闭原则。因此，它只使用于产品数较少，产品变化的需求较少的场景。 工厂方法设计模式将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定。 共有4个角色：抽象产品类、具体产品类、抽象工厂类、具体工厂类 代码实现工厂接口： public interface FruitFactory &#123; Fruit createFruit();//生产水果 &#125; 苹果工厂： public class AppleFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Apple(); &#125; &#125; 梨工厂： public class PearFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Pear(); &#125; &#125; 使用： AppleFactory appleFactory = new AppleFactory(); PearFactory pearFactory = new PearFactory(); Apple apple = (Apple) appleFactory.createFruit();//获得苹果 Pear pear = (Pear) pearFactory.createFruit();//获得梨 缺点这种方式，虽然解耦成功，也遵循了开闭原则，但是最根本的问题依然存在，如果需要增加水果的话，还得创建大量的工厂类，很麻烦。 抽象工厂设计模式为创建一组相关或者是相互依赖的产品族提供的一个接口，而不需要指定它们的具体类。 代码实现cpu接口和实现类： public interface Cpu &#123; void run(); class Cpu650 implements Cpu &#123; @Override public void run() &#123; //625 也厉害 &#125; &#125; class Cpu825 implements Cpu &#123; @Override public void run() &#123; //825 处理更强劲 &#125; &#125; &#125; 屏幕和接口实现类： public interface Screen &#123; void size(); class Screen5 implements Screen &#123; @Override public void size() &#123; //5寸 &#125; &#125; class Screen6 implements Screen &#123; @Override public void size() &#123; //6寸 &#125; &#125; &#125; 工厂接口： public interface PhoneFactory &#123; Cpu getCpu();//使用的cpu Screen getScreen();//使用的屏幕 &#125; 实现： public class HongMiFactory implements PhoneFactory &#123; @Override public Cpu getCpu() &#123; return new Cpu.Cpu650();//高效处理器 &#125; @Override public Screen getScreen() &#123; return new Screen.Screen5();//小屏手机 &#125; &#125; 以上例子可以看出，抽象工厂可以解决一系列的产品生产的需求，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展； 总结 对于简单工厂和工厂方法来说，两者的使用方式实际是一样的，对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式。毕竟效果都一样，何必要用一个写起来更麻烦的方法呢。 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"对象的内存布局和创建","slug":"对象的内存布局和创建","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:52:11.112Z","comments":true,"path":"2021/05/22/dui-xiang-de-nei-cun-bu-ju-he-chuang-jian/","link":"","permalink":"http://example.com/2021/05/22/dui-xiang-de-nei-cun-bu-ju-he-chuang-jian/","excerpt":"","text":"对象的内存布局和创建1. 对象的内存布局对象的内存布局分为3个区域：Header（对象头）、Instance Data（实例数据）、Padding（对齐填充） Header（对象头） 运行时的数据（Mark Word）：如HashCode（哈希码）、GC分代年龄、锁状态标志、线程持有的锁等等 类型指针：通过这个指针确定这个对象属于哪个类 Instance Data（实例数据）这部分是存储真正的有效信息，也就是在程序代码中所定义的各种类型的字段内容。 Padding（对齐填充）这部分信息没有任何意义，仅仅是为了使得对象占的内存大小为8字节的整数倍。 2. 对象的创建在语言层面，使用new关键字即可创建出一个对象。但是在虚拟机中，对象创建的创建过程则是比较复杂的。 (1) 首先，虚拟机运到new指令时，会去常量池检查是否存在new指令中包含的参数，比如new People(),则虚拟机首先会去常量池中检查是否有Student这个类的符号引用，并且检查这个类是否已经被加载了，如果没有则会执行类加载过程。 (2) 在类加载检查过后，接下来为对象分配内存当然是在java堆中分配。 (3) 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也许会提前值TLAB分配时进行。这一步保证了对象实例字段在Java中不赋值也可以直接使用。 (4) 接来下，虚拟机对对象进行必要的设置，例如这个对象属于哪个类的实例，如何找到类的元数据信息。对象的哈希吗、对象的GC年代等信息，这些信息都存放在对象头之中。 (5) 执行完上面工作之后，所有的字段都为0，接着执行指令，把对象按照程序员的指令进行初始化，这样一个对象就完整的创建出来。 这就完了吗？？？？当然没有！！请往下看！ 3. 对象空间的分配Java堆为对象分配内存的方式有两种：Bump the Pointer(指针碰撞)和Free List(空闲列表) **Bump the Pointer(指针碰撞)**：假设Java堆中的内存都放在一起，所有是使用过的内存放到一边，空闲的内存放到另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅把指针相空闲空间的方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞” **Free List(空闲列表)**：当使用内存和空闲内存交织在一起时，JVM需要维护一个列表，记录哪些内存是可用的，在给对象分配内存时从列表中找到一块足够大的内存空间划分给对象，并更新列表上的记录。这种分配方式称之为“空闲列表” Java Heap内存采用哪种分配方式取决于Java Heap内存是否带有空间压缩整理的能力决定。也就是说有垃圾回收器采用哪种回收算法来决定的。当垃圾回收器采用的是标记-清理算法，如CMS垃圾回收器，那么使用的就是空闲列表的分配方式。当使用Serial、parNew等带有压缩整理过程的收集器，采用的是指针碰撞的内存分配方式 4. 对象的访问对象的访问方式主流的有两种：句柄访问方式和直接指针访问方式 句柄访问方式在Java堆中划分一块内存来作为句柄池，句柄池中包含了对象数据和对象类型的具体地址信息。通过这些信息可以访问到对象实例数据和对象类型数据。Java栈中的reference存储对象的句柄池地址即可。如图： 直接指针访问方式reference中存储的就是对象地址。如图： 二者优势句柄访问方式的优势就是稳定，reference中存储的是稳定的句柄地址，在对象移动时只会改变句柄中实例数据的指针，而reference本身不被修改。 直接访问方式的优势就是速度快，节省了指针定位的时间开销 HotSpot虚拟机采用的是直接指针访问方式","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"模板模式（Template Pattern）","slug":"模板模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:48:06.212Z","comments":true,"path":"2021/05/22/mo-ban-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/mo-ban-mo-shi/","excerpt":"","text":"模板模式（Template Pattern）完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。这就是模板模式。 1. 定义定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 2. 优缺点优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 3. 原理角色 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中申明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 结构图 4. 代码实现老规矩，举个栗子。迎接客人，而这个迎接客人的流程是一样的，都是visit、talk、bye。但是根据客人身份的不同，实现的方式也不同，这里设定的是两种客人，一种是儿子带女朋友回家，一个是女儿带男朋友回家。 抽象类： /** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */ public abstract class Welcome &#123; public abstract void visit(); public abstract void talk(); public abstract void bye(); public void run()&#123; visit(); talk(); bye(); &#125; &#125; 迎接儿子女朋友的实现类： package com.yang.template; /** * @program: LoverOfSon * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:51 */ public class LoverOfSon extends Welcome &#123; public void visit() &#123; System.out.println(\"来就来嘛还带这么多东西\"); &#125; public void talk() &#123; System.out.println(\"这姑娘真不错\"); &#125; public void bye() &#123; System.out.println(\"20w彩礼，你看看够不够，不够我们再加\"); &#125; &#125; 迎接女儿男朋友的实现类： package com.yang.template; /** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */ public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(\"除了华子，送别的烟我不抽，拉嗓子\"); &#125; public void talk() &#123; System.out.println(\"有车吗？有房吗？有什么学位？\"); &#125; public void bye() &#123; System.out.println(\"没50w彩礼别想娶我家姑娘\"); &#125; &#125; 测试类： package com.yang.template; /** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:56 */ public class MyDemo &#123; public static void main(String[] args) &#123; Welcome loverOfSon = new LoverOfSon(); loverOfSon.run(); System.out.println(); Welcome loverOfDaughter = new LoverOfDaughter(); loverOfDaughter.run(); &#125; &#125; 运行结果 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？没50w彩礼别想娶我家姑娘 可见这个模式已经实现。但是此时还有一个新问题，如果说客人来了，还得吃饭，老头还得喝点。那么就需要在Welcome流程里加一个喝酒类，但是也不行，如果是儿子带女朋友回来的话，让人一姑娘喝酒也不合适。这时我们要解决的问题就是，通过子类的操作来实现，对父类流程的调控。因此我们用了一个钩子方法来解决这个问题。下面我们对上面的代码进行改造。 Welcaome类： package com.yang.template; /** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */ public abstract class Welcome &#123; protected boolean isDrink()&#123; return false; &#125; protected abstract void visit(); protected abstract void talk(); protected abstract void bye(); protected void Drink()&#123; System.out.println(\"哈啤酒~~~\"); &#125; public void run()&#123; visit(); talk(); if (isDrink())&#123; Drink(); &#125; bye(); &#125; &#125; LoverOfDaughter类： package com.yang.template; /** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */ public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(\"除了华子，送别的烟我不抽，拉嗓子\"); &#125; public void talk() &#123; System.out.println(\"有车吗？有房吗？有什么学位？\"); &#125; @Override protected boolean isDrink() &#123; return true; &#125; @Override protected void Drink() &#123; System.out.println(\"喝白的\"); &#125; public void bye() &#123; System.out.println(\"没50w彩礼别想娶我家姑娘\"); &#125; &#125; 其他类保持原样，运行之后的效果如下： 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？喝白的没50w彩礼别想娶我家姑娘 我们以上的问题已经解决，在这次改进中，我给isDrick()方法了初始值，就是不喝，也给了Drink()方法了初始值。这样子类就可以根据需要进行选择重写或者不重写。 这就是我们的模板模式，看完之后可能第一感觉就是，非常熟悉。是的，我们的编码过程中，经常使用，但是不知道它的名字而已。设计模式仅仅是一个设计过程中的技巧和模式。在实际开发中，知不知道他的名字无所谓，到了使用的时候，自然就用出来了。这就是传说中的，无招胜有招。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"建造者模式（Builder Patttern）","slug":"建造者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:47:18.780Z","comments":true,"path":"2021/05/22/jian-zao-zhe-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/jian-zao-zhe-mo-shi/","excerpt":"","text":"建造者模式（Builder Patttern）在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。这时就需要建造者模式来解决。 1. 定义指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 2. 优缺点优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 3. 原理主要角色 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：也叫导演类，它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 结构图 实现步骤 创建抽象建造者定义造房步骤 创建工人具体实现造房步骤 创建承包商指挥工人施工 验收，检查是否建造完成 4. 代码实现产品类package com.yang.builder; /** * @program: Product * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:41 */ public class Product &#123; private String buildA; private String buildB; private String buildC; private String buildD; public String getBuildA() &#123; return buildA; &#125; public void setBuildA(String buildA) &#123; this.buildA = buildA; &#125; public String getBuildB() &#123; return buildB; &#125; public void setBuildB(String buildB) &#123; this.buildB = buildB; &#125; public String getBuildC() &#123; return buildC; &#125; public void setBuildC(String buildC) &#123; this.buildC = buildC; &#125; public String getBuildD() &#123; return buildD; &#125; public void setBuildD(String buildD) &#123; this.buildD = buildD; &#125; @Override public String toString() &#123; return \"Product&#123;\" + \"buildA='\" + buildA + '\\'' + \", buildB='\" + buildB + '\\'' + \", buildC='\" + buildC + '\\'' + \", buildD='\" + buildD + '\\'' + '&#125;'; &#125; &#125; 建造类package com.yang.builder; /** * @program: Build * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:43 */ public abstract class Build &#123; public abstract Build setBuildA(); public abstract Build setBuildB(); public abstract Build setBuildC(); public abstract Build setBuildD(); public abstract Product getProduct(); &#125; 具体建造者类package com.yang.builder; /** * @program: Worker * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:45 */ public class Worker extends Build &#123; private Product product; public Worker() &#123; product = new Product(); &#125; public Build setBuildA() &#123; product.setBuildA(\"地基\"); return this; &#125; public Build setBuildB() &#123; product.setBuildB(\"钢金\"); return this; &#125; public Build setBuildC() &#123; product.setBuildC(\"水电\"); return this; &#125; public Build setBuildD() &#123; product.setBuildD(\"粉刷\"); return this; &#125; public Product getProduct() &#123; return product; &#125; &#125; 导演类package com.yang.builder; /** * @program: Derict * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:48 */ public class Derict &#123; public Product create(Build build)&#123; build.setBuildA().setBuildB().setBuildC().setBuildD(); return build.getProduct(); &#125; &#125; 客户类package com.yang.builder; /** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:50 */ public class MyDemo &#123; public static void main(String[] args) &#123; Derict derict = new Derict(); Product product = derict.create(new Worker()); System.out.println(product); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"静态代理模式（Static Proxy）","slug":"静态代理模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:47:21.779Z","comments":true,"path":"2021/05/22/jing-tai-dai-li-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/jing-tai-dai-li-mo-shi/","excerpt":"","text":"静态代理模式（Static Proxy）1. 定义给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。防止直接访问目标对象给系统带来的不必要复杂性。 2. 优缺点优点 可以使真是角色的操作更加纯粹，不用去关心一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点 一个真是角色会产生一个代理角色，代码量翻倍，开发效率低！ 实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 3. 原理角色 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 结构图 实现步骤 创建抽象对象接口（Subject） 创建真实对象类（RealSubject） 创建代理对象类（Proxy） 客户端调用 4. 代码实现比如，现在我要租一个房子，但是我又不想自己去找房东，也不想自己去谈价钱，看房子这些破事儿，我就可以去找中介代理帮我做。 创建一个Rent接口package com.yang.proxy.demo1; public interface Rent &#123; public void rentRoom(); &#125; 创建一个真实对象类package com.yang.proxy.demo1; /** * @program: Client * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:52 */ public class Client implements Rent &#123; public void rentRoom() &#123; System.out.println(\"我是客户，我要租房子\"); &#125; &#125; 创建代理对象类package com.yang.proxy.demo1; /** * @program: Proxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:53 */ public class Proxy implements Rent &#123; private Client client; public Proxy() &#123; &#125; public Proxy(Client client) &#123; this.client = client; &#125; public void rentRoom() &#123; lookRoom(); client.rentRoom(); bargin(); &#125; public void bargin()&#123; System.out.println(\"我是中介，我在讲价\"); &#125; public void lookRoom()&#123; System.out.println(\"我是中介，我在看房\"); &#125; &#125; 调用package com.yang.proxy.demo1; /** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:54 */ public class MyDemo &#123; public static void main(String[] args) &#123; Client client = new Client(); Proxy proxy = new Proxy(client); proxy.rentRoom(); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"观察者模式（Observer Pattern）","slug":"观察者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T09:47:55.282Z","comments":true,"path":"2021/05/22/guan-cha-zhe-mo-shi/","link":"","permalink":"http://example.com/2021/05/22/guan-cha-zhe-mo-shi/","excerpt":"","text":"观察者模式（Observer Pattern）在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。 1. 定义指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 2. 优缺点优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 3. 实现角色 抽象对象（IObject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体对象（Concrete Object）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 模式图 4. 代码抽象对象类： package com.yang.observe; import java.util.ArrayList; import java.util.List; /** * @program: IObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:02 */ public abstract class IObject &#123; protected List&lt;IObserver> list=new ArrayList&lt;IObserver>(); //增加观察者方法 public void add(IObserver observer) &#123; list.add(observer); &#125; //删除观察者方法 public void remove(IObserver observer) &#123; list.remove(observer); &#125; //通知观察者方法 public abstract void notifyObserver(); &#125; 具体对象类： package com.yang.observe; /** * @program: ConcreteObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:05 */ public class ConcreteObject extends IObject &#123; public void notifyObserver() &#123; System.out.println(\"目标角色发生了变化\"); for (IObserver observer : super.list) &#123; observer.response(\"ConcreteObject发生变化\"); &#125; &#125; &#125; 观察者接口： package com.yang.observe; /** * @program: IObserver * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */ public interface IObserver &#123; public void response(String msg); &#125; 具体观察者1 package com.yang.observe; /** * @program: Observer * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */ public class Observer1 implements IObserver&#123; public void response(String msg) &#123; System.out.println(\"Observer01知道了[\" + msg + \"]\" ); &#125; &#125; 具体观察者2： package com.yang.observe; /** * @program: Observer2 * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:10 */ public class Observer2 implements IObserver&#123; public void response(String msg) &#123; System.out.println(\"Observer02知道了[\" + msg + \"]\" ); &#125; &#125; 测试类： package com.yang.observe; /** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:11 */ public class MyDemo &#123; public static void main(String[] args) &#123; Observer1 observer1 = new Observer1(); Observer2 observer2 = new Observer2(); ConcreteObject concreteObject = new ConcreteObject(); concreteObject.add(observer1); concreteObject.add(observer2); concreteObject.notifyObserver(); &#125; &#125; 运行结果： 目标角色发生了变化Observer01知道了[ConcreteObject发生变化]Observer02知道了[ConcreteObject发生变化]","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"对象已死吗","slug":"对象已死吗","date":"2021-05-22T05:02:30.000Z","updated":"2021-05-22T09:48:57.645Z","comments":true,"path":"2021/05/22/dui-xiang-yi-si-ma/","link":"","permalink":"http://example.com/2021/05/22/dui-xiang-yi-si-ma/","excerpt":"","text":"对象已死吗？Java Heap中存放着几乎所有的对象实例，垃圾回收前，最重要的事就是判断是对象是否存活（还在被引用的对象）。 1. 引用计数法给对象添加一个引用计数器,每一个地方引用它,计数器值就加1，对象引用失效的时候,计数器就减1.计数器值为0的时候,此对象为垃圾。 优点：判定效率高 缺点:如果对象间循环依赖,此算法无法正确判断是否为垃圾对象。因此主流虚拟机都没有用这种算法。 循环依赖如下图所示： 2. 可达性分析算法目前主流的JVM都是用的可达性分析算法来判断对象是否存货的。 实现方法GC Roots的对象作为起始点从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain)当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达的。如下图： 图中黄色的对象仍然存活，灰色的显然是不可达的，即为可回收的对象。 可作为GC Root对象的包括 栈帧中本地变量表中引用的对象 方法区类静态属性引用的对象 方法区中常量引用的对象 方法栈JNI引用的对象 关于引用（强软弱虚）强引用：类似于Object obj = new Object()这种的就属于强引用，只要强引用存在，就永远不会被回收。 软引用：有用，但是非必须的对象。对于这些软引用关联的对象，在要发生内存异常前，将会把他们列到回收范围中进行GC，如果内存依然不够，才会报内存溢出异常。 弱引用：非必须对象，被若引用关联的对象只能生存到下一次GC发生之前。当开始GC时，无论内存是否够用，都会回收。 虚引用：最弱的一种引用关系，一个对象是否有虚引用，完全不影响其生存时间，，也无法通过虚引用来取得一个对象实例。为对象设置虚引用的唯一目的就是能在这个对象被回收时，收到一个系统通知。 3. 不可达对象是否死亡判断当对象不可达GC Roots时，将会对其进行第一次筛选，如果其未覆盖finalize()方法或者已经调用过一次finalize()方法的话，讲直接将其回收。否则，将会给其一个逃脱死亡命运的机会，并对其标记。如果到第二次GC时，它还没有被引用的话，那将会被直接回收。 4. Method Area的回收此区域的垃圾回收效率较低。 一般回收两部分内容，即：废弃常量和无用的类。 废弃常量：如果无任何地方引用此常量，那么它讲在下一次GC时被回收。 无用的类：需要同时达到以下三个条件: 该类所有实例都被回收 加载该类的ClassLoader被回收 该类对应的class对象没有被引用,无法在任何地方反射访问该类方法","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-22T04:48:48.914Z","updated":"2021-05-22T04:48:48.914Z","comments":true,"path":"2021/05/22/hello-world/","link":"","permalink":"http://example.com/2021/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"SpringBoot自定义异常视图","slug":"SpringBoot自定义异常视图","date":"2021-05-21T07:24:52.000Z","updated":"2021-05-22T09:51:09.985Z","comments":true,"path":"2021/05/21/springboot-zi-ding-yi-yi-chang-shi-tu/","link":"","permalink":"http://example.com/2021/05/21/springboot-zi-ding-yi-yi-chang-shi-tu/","excerpt":"","text":"SpringBoot自定义异常视图一、异常视图原理源码阅读DefualtErrorViewResolver.java private static final Map&lt;Series, String> SERIES_VIEWS; static &#123; Map&lt;Series, String> views = new EnumMap&lt;>(Series.class); views.put(Series.CLIENT_ERROR, \"4xx\"); views.put(Series.SERVER_ERROR, \"5xx\"); SERIES_VIEWS = Collections.unmodifiableMap(views); &#125; /** * @param request * @param status 状态码 * @param model map集合，存放异常信息 * @return ModelAndView */ @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object> model) &#123; //去拿相应的ModelAndView。如果有相应的异常页面文件(文件名为具体状态码的文件)，否则拿到对象为null ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); //如果没有相应的异常页面文件(文件名为具体状态码的文件)，且状态码属于4xx、5xx的，进行如下处理 if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; //如果有相应的异常页面文件(SERIES_VIEWS)，否则拿到对象为null modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; /** * * @param viewName 视图名 * @param model map集合，存放异常信息 * @return ModelAndView */ private ModelAndView resolve(String viewName, Map&lt;String, Object> model) &#123; //给视图名加个上“error/” String errorViewName = \"error/\" + viewName; //查看是否有模板提供者 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,this.applicationContext); //如果有的话，直接按照动态的处理方式返回ModelAndView对象 if (provider != null) &#123; return new ModelAndView(errorViewName, model); &#125; //如果没有，进行静态资源的处理 return resolveResource(errorViewName, model); &#125; /** * * @param viewName 视图名 * @param model map集合，存放异常信息 * @return ModelAndView */ private ModelAndView resolveResource(String viewName, Map&lt;String, Object> model) &#123; //遍历静态资源路径 for (String location : this.resources.getStaticLocations()) &#123; try &#123; //拿到静态资源对象 Resource resource = this.applicationContext.getResource(location); //确定该资源是否以物理形式存在 resource = resource.createRelative(viewName + \".html\"); if (resource.exists()) &#123; //若存在，返回ModelAndView return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; //否则，返回null return null; &#125; 流程图如下 二、实现自定义自定义自己的异常视图也是重写resolveErrorView() 函数。不过不需要再写这个麻烦的判断，直接返回一个ModelAndview带视图名和错误信息。 MyErrorViewResolver.java:/** * @program: MyErrorViewResolver * @description: 自定义异常视图 * @author: yangxun199807@163.com * @create: 2020-12-13 21:07 */ @Component public class MyErrorViewResolver extends DefaultErrorViewResolver &#123; public MyErrorViewResolver(ApplicationContext applicationContext, WebProperties.Resources resources) &#123; super(applicationContext, resources); &#125; @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object> model) &#123; ModelAndView mv = new ModelAndView(); mv.setViewName(\"yang\"); mv.addAllObjects(model); return mv; &#125; &#125; yang.html:&lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>ERROR&lt;/title> &lt;/head> &lt;body> &lt;h2>Yang.html&lt;/h2> &lt;table border=\"1\"> &lt;tr> &lt;td>path&lt;/td> &lt;td th:text=\"$&#123;path&#125;\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>timestamp&lt;/td> &lt;td th:text=\"$&#123;timestamp&#125;\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>message&lt;/td> &lt;td th:text=\"$&#123;message&#125;\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>error&lt;/td> &lt;td th:text=\"$&#123;error&#125;\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>status&lt;/td> &lt;td th:text=\"$&#123;status&#125;\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>exception&lt;/td> &lt;td th:text=\"$&#123;exception&#125;\">&lt;/td> &lt;/tr> &lt;/table> &lt;/body> &lt;/html> 运行结果","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://example.com/categories/Spring%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"Java常用集合","slug":"Java常用集合","date":"2021-05-21T07:17:56.000Z","updated":"2021-05-22T09:52:03.484Z","comments":true,"path":"2021/05/21/java-chang-yong-ji-he/","link":"","permalink":"http://example.com/2021/05/21/java-chang-yong-ji-he/","excerpt":"","text":"java常用集合集合1. Java集合分类Java常用集合主要分为Collection和Map两大类： Collection：是单列集合的顶层父类，是一个独立元素的序列，这些个元素都服从一条或者多条规则。List必须按照插入的顺序保存元素，而Set不能有重复的元素。即Collection分为List和Set两大分支。 (1) List集合是一个有序的队列，每一个元素都有他的索引。第一个元素的索引值为0。 ` List的实现类有LinkedList、ArrayList、Vector、Stack。 (2) Set集合是一个不允许有重复元素的集合。 ​ Set的实现类有HashSet、TreeSet。HashSet依赖于HashMap，他实际上是通过HashMap实现的；TreeSet依赖 于TreeMap，他实际是通过TreeMap实现的。 Map：是双列集合的顶层父类接口，是一个映射接口，即key-Value键值对。允许使用键来查找对应的值，从某种意义上来说，他将数字和对象关联在一起。Map中的每一个元素包含”key”和”key对应的value”。 (1) AbstractMap是一个抽象类，它实现了Map接口中的大部分API。二HashMap、TreeMap、WeakHashMap都是继承了AbstractMap。Hashtable虽然继承与Dictionary，但是他实现了Map接口。 2. 关于集合类(Collection) Collection是集合的父类，但是JDK不提供直接继承自Collection的集合类让用户使用，而是提供继承自Collection子接口List和Set的集合类让用户使用。 List和Set的区别，List提供了随机访问的方法，内部元素是有序的，并且允许为空；而实现Set接口的类，内部元素是无序的，并且最多只能有一个null元素，并且放入Set中的元素必须不相等，就是要满足e1.equals(e2)==false，另外必须小心操作可变对象，当Set中的可变对象被操作后使得Set中有两个元素满足了e1.equals(e2)==true时就会发生一些问题。 ArrayList类。ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 LikedList。它内部的结构是基于链表的。LinkedList实现了List接口，允许null元素。此外LinkedList实现了Deque, Queue接口，提供额外的get，remove，insert方法在LinkedList的首部或尾部。所以LinkedList可以用来实现队列操作。它也是非同步的。 Vector。它与ArrayList非常相似，但是Vector是同步的。 HashSet。它内部是使用Hash表来存放元素的，通过HashMap来实现的。元素 3. 关于容器类(Map) 容器的父接口是Map，它提供了键值对的数据结构。 HashMap。跟HashSet相似，它也是基于Hash函数的，所以作为HashMap的键值的类，必须重写hash和equals方法。它是非同步的，允许null的key和null的value。 Hashtable。它也是实现Map的一个子类，它跟HashMap非常相似，但是Hashtable是同步的，并且不允许有null的key和null的value。 TreeMap。内部结构是基于红黑树的，内部的键值集合是有序的，可以进行基于有序的相关操作，其他操作跟HashMap相似。 WeakHashMap。该类与HashMap相似，只是它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 4. 关于Collections类这是一个工具类，它的静态方法一般用来处理集合容器类，或者用来生产集合容器类。Collections.synchronizedXXX()方法可以从非同步的集合容器类获得同步的集合容器类。 5. 关于Arrays类Arrays类提供了很多处理数组相关的静态方法，如数组的查找、比较、排序等操作。另外该类还提供了一个静态方法，将数组转换成List，该方法就是 Arrays.asList(T ... array); 6. 同步的集合类以及容器类（Synchronized）一般的集合类和容器类都是非同步的（除了Vector和Hashtable以及它们的子类），如果用在多线程环境下必须自己写有关同步的代码。JDK中为我们提供了与一般集合容器类相应的同步类，SynchronizedCollection、SynchronizedList、SynchronizedMap、SynchronizedSet、SynchronizedSortedSet、SynchronizedMap，这些类都是Collections类中的静态内部类，通过Collections.synchronizedXXX()方法就可以获得相关的同步集合容器类，并且得到的同步类与作为参数的非同步类共享数据空间，当在同步类中对集合或者容器做出修改，在非同步的类中能同步感受到。例如 List&lt; String> list = new LinkedList&lt;>(); list.add(\"one\"); List&lt;String> list1 = Collections.synchronizedList(list); list1.remove(0); System.out.println(list.size()); 上述代码输出结果为0 7. 并发的集合类以及容器类 同步集合或容器中，基本上在内部是使用synchronized来实现的，而且一个类中所有的方法使用的是同一个锁对象，在很多这会造成性能上的问题。另外，有一些复合操作，需要保持原子性，如获取最后一个元素（代码见下面），而同步类这时候就做不到了，所以这时候要考虑使用并发类了，并发类位于java.util.concurrent中。 /** *获取最后一个元素 */ public static Object getLast(Vector list) &#123; int lastIndex = list.size() - 1; return list.get(lastIndex); &#125; 并发容器有ConcurrentHashMap，它采用更细粒度的锁，被称为分段锁，允许一定数量的线程并发的修改它，能够提供高并发的性能。 还有一些有用的适用于某些并发场合的集合类，CopyOnWriteArrayList等。 在这里只要Java中存在同步集合容器和并发集合容器类就可以了，当遇到多线程的情况或者要求并发的情况下，再去找相关的合适的同步或并发的集合容器类。 8. UML图","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring框架","slug":"Spring框架","permalink":"http://example.com/categories/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]}