{"meta":{"title":"LittleY'Blog","subtitle":"","description":"","author":"LittleY","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"策略模式(Stratagy)","slug":"策略模式","date":"2021-05-22T06:45:30.000Z","updated":"2021-05-22T06:45:36.734Z","comments":true,"path":"2021/05/22/策略模式/","link":"","permalink":"http://example.com/2021/05/22/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式(Stratagy)定义策略模式 定义一系列算法，把他们独立封装起来，并且这些算法之间可以相互替换。策略模式主要是管理一堆有共性的算法，策略模式让算法独立于使用它的客户而变化，客户端可以根据需要，很快切换这些算法，并且保持可扩展性。 比如说，我有一个排序方法，但是这个排序的规则有好几种，比如说，针对一个实体类的id进行排序，也可以针对实体类的age进行排序等等还多中规则，这些规则我都是可以随时替换的。而策略模式就是来处理这一类问题。 优缺点优点： 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点： ​ 策略模式造成很多的策略类。 原理策略模式的原理图如下： Strategy类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法。 Concrete Strategy类：实现了抽象策略定义的接口，也就是真正干活的类 Context类：持有一个策略类的引用，最终给客户端调用 注意：Context也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 举个例子此时要开发一款软件，可以使用Java，也可以使用PHP，这两个语言属于两个策略。现在使用策略模式来实现这个问题。 抽象语言类 123public interface CodeLanguage &#123; void useLanguage();&#125; 具体语言类 123456public class CodeJava implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(&quot;使用Java语言编程&quot;); &#125;&#125; 123456public class CodePhp implements CodeLanguage &#123; @Override public void useLanguage() &#123; System.out.println(&quot;使用Php语言编程&quot;); &#125;&#125; 策略引用类 1234567891011public class CodeContext &#123; CodeLanguage codeLanguage; public CodeContext1(CodeLanguage codeLanguage) &#123; this.codeLanguage = codeLanguage; &#125; void useLanguage()&#123; codeLanguage.useLanguage(); &#125;&#125; 使用模式 123456789public class Application &#123; public static void main(String[] args) &#123; CodeContext context; context = new CodeContext(new CodeJava()); context.useLanguage(); context = new CodeContext(new CodePhp()); context.useLanguage(); &#125;&#125; 此时，这个模型就已经用代码表示出来了，此时我们也不难发现，如果现在需要再增加一种策略的话，只需要新建一个CodeLanguage的实现类就可以了，在使用的时候可以直接调用策略。体现了它的扩展性","categories":[],"tags":[]},{"title":"单例模式","slug":"单例模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:42:49.254Z","comments":true,"path":"2021/05/22/单例模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式在有些开发场景中，没有必要有多个实例存在，以节省资源。比如说 PropertiyMgr 工具类 饿汉式实现代码如下： 12345678910111213141516171819public class Mgr01 &#123; private static final Mgr01 INSTANCE = new Mgr01(); private Mgr01() &#123;&#125;; public static Mgr01 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr01 m1 = Mgr01.getInstance(); Mgr01 m2 = Mgr01.getInstance(); System.out.println(m1 == m2); &#125;&#125; 还有一种写法，和上面的写法效果一模一样： 12345678910111213141516171819202122public class Mgr02 &#123; private static final Mgr02 INSTANCE; static &#123; INSTANCE = new Mgr02(); &#125; private Mgr02() &#123;&#125;; public static Mgr02 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr02 m1 = Mgr02.getInstance(); Mgr02 m2 = Mgr02.getInstance(); System.out.println(m1 == m2); &#125;&#125; 优点：类加载到内存后，就实例化一个单例，JVM 保证线程安全简单实用，推荐使用！ 缺点：不管用到与否，类装载时就完成实例化。如果用不上它的话，装载它会造成资源浪费。 由此我们有了另一个解决方案，那就是懒汉式： 懒汉式（Lazy Loading）第一种写法实现代码如下： 12345678910111213141516171819202122public class Mgr03 &#123; private static Mgr03 INSTANCE; private Mgr03() &#123; &#125; public static Mgr03 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr03(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 由上面代码可知，使用懒汉式之后，达到了按需初始化的目的。但是随之而来的是更严重的问题，那就是它的线程不安全问题。 就是说，两个线程如果接近同时进入 INSTANCE == null 的判断语句时，两个都会进入里面的代码块进行new对象。可知此时两个线程拿到的实例就不是同一个实例。这就是线程不安全问题。可以用以下测试代码对其进行测试： 1234567public static void main(String[] args) &#123; for(int i=0; i&lt;100; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Mgr04.getInstance().hashCode()); &#125;).start(); &#125;&#125; 为了解决线程不安全的问题，我们又进行了以下优化： 第二种写法代码如下： 12345678910111213141516171819202122public class Mgr04 &#123; private static Mgr04 INSTANCE; private Mgr04() &#123; &#125; public static synchronized Mgr04 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr04(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 我们对实例方法进行了加锁处理，保证了线程安全的问题。但是，不难想象，如果有大量的线程访问的话，那么它的效率会大幅下降。 我们再做一下优化： 123456789101112131415161718192021222324public class Mgr05 &#123; private static Mgr05 INSTANCE; private Mgr05() &#123; &#125; public static Mgr05 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Mgr05.class) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr05(); &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次我们把锁加在了实例方法里面的Mgr05.class上，妄图通过减小同步代码块的方式提高效率，测试后，不可行。 原因是，虽然对Mgr05.class进行了加锁，但是如果两个线程同时进入INSTANCE==null代码块里面，它依然会new出两个不同的实例。 现在可知，问题就处在了INSTANCE == null判断语句这块儿，那么我们针对这块儿进行优化。 第三种写法123456789101112131415161718192021222324252627public class Mgr06 &#123; private static Mgr06 INSTANCE; //JIT private Mgr06() &#123; &#125; public static Mgr06 getInstance() &#123; if (INSTANCE == null) &#123; //双重检查 synchronized (Mgr06.class) &#123; if(INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr06(); &#125; &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次优化，我们针对的就是判断实例是否为空这个点，进行了双层检查，即使两个同时进入了第一层判断，一个拿到锁之后，先实例化了一个对象，第二个再进去之后，还需要第二只判断，如果已经有了实例，那么就直接跳出，不再new新的实例。 这时可能会有个疑问，那么外层的检查还有必要存在吗？答案是当然需要，如果没有了外层的判断，每个线程都要加锁上锁，不得把JVM累死，下可能自然就变差了。 静态内部类方式代码如下： 12345678910111213141516public class Mgr07 &#123; private Mgr07() &#123; &#125; private volatile static class Mgr07Holder &#123; private final static Mgr07 INSTANCE = new Mgr07(); &#125; public static Mgr07 getInstance() &#123; return Mgr07Holder.INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这个方法算是目前来说比较完美的一种写法。JVM保证单例，加载外部类时不会加载内部类，这样可以即可以实现懒加载，还能保证线程安全。 注意使用volatile修饰单例对象，目的是保证多线程环境下的线程安全。 枚举类方法代码如下： 1public enum Mgr08 &#123; INSTANCE; public void m() &#123;&#125;&#125; 这是《Java Effective》这本书中的一种写法，写法简单，还能保证线程同步问题，还可以防止反序列化(通俗点说就是防止反射对其造成的破坏)。中功能上来说是所有单例模式写法中最完美的。但是个人不推荐这种写法，比较别扭，不够优雅。 设计模式是一种生产技巧和模式，没有必要像孔乙己一样研究茴字有几种写法，以实际开发的场景的选择不同的写法。","categories":[],"tags":[]},{"title":"工厂模式","slug":"工厂模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:46:42.460Z","comments":true,"path":"2021/05/22/工厂模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式工厂设计模式，就是用来生产对象的，在Java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则，如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦 一共有3中工厂设计模式：简单工厂、工厂方法、抽象工厂 简单工厂设计模式一个工厂方法，依据传入的参数，生成对应的产品对象。 共有3个角色：抽象产品、局具体产品、具体工厂 代码实现水果接口： 123public interface Fruit &#123; void whatIm();&#125; 具体类： 123456public class Apple implements Fruit &#123; @Override public void whatIm() &#123; //苹果 &#125;&#125; 123456public class Pear implements Fruit &#123; @Override public void whatIm() &#123; //梨 &#125;&#125; 具体工厂： 123456789101112public class FruitFactory &#123; public Fruit createFruit(String type) &#123; if (type.equals(&quot;apple&quot;)) &#123;//生产苹果 return new Apple(); &#125; else if (type.equals(&quot;pear&quot;)) &#123;//生产梨 return new Pear(); &#125; return null; &#125;&#125; 使用产品： 123FruitFactory mFactory = new FruitFactory();Apple apple = (Apple) mFactory.createFruit(&quot;apple&quot;);//获得苹果Pear pear = (Pear) mFactory.createFruit(&quot;pear&quot;);//获得梨 缺点这个设计模式的缺点显而易见，当我需要添加一种水果的时候，我不但需要新建一个水果的类，还需要修改工厂类。违反了开闭原则。因此，它只使用于产品数较少，产品变化的需求较少的场景。 工厂方法设计模式将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定。 共有4个角色：抽象产品类、具体产品类、抽象工厂类、具体工厂类 代码实现工厂接口： 123public interface FruitFactory &#123; Fruit createFruit();//生产水果&#125; 苹果工厂： 123456public class AppleFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Apple(); &#125;&#125; 梨工厂： 123456public class PearFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Pear(); &#125;&#125; 使用： 1234AppleFactory appleFactory = new AppleFactory();PearFactory pearFactory = new PearFactory();Apple apple = (Apple) appleFactory.createFruit();//获得苹果Pear pear = (Pear) pearFactory.createFruit();//获得梨 缺点这种方式，虽然解耦成功，也遵循了开闭原则，但是最根本的问题依然存在，如果需要增加水果的话，还得创建大量的工厂类，很麻烦。 抽象工厂设计模式为创建一组相关或者是相互依赖的产品族提供的一个接口，而不需要指定它们的具体类。 代码实现cpu接口和实现类： 1234567891011121314151617public interface Cpu &#123; void run(); class Cpu650 implements Cpu &#123; @Override public void run() &#123; //625 也厉害 &#125; &#125; class Cpu825 implements Cpu &#123; @Override public void run() &#123; //825 处理更强劲 &#125; &#125;&#125; 屏幕和接口实现类： 1234567891011121314151617181920public interface Screen &#123; void size(); class Screen5 implements Screen &#123; @Override public void size() &#123; //5寸 &#125; &#125; class Screen6 implements Screen &#123; @Override public void size() &#123; //6寸 &#125; &#125;&#125; 工厂接口： 123456public interface PhoneFactory &#123; Cpu getCpu();//使用的cpu Screen getScreen();//使用的屏幕&#125; 实现： 123456789101112public class HongMiFactory implements PhoneFactory &#123; @Override public Cpu getCpu() &#123; return new Cpu.Cpu650();//高效处理器 &#125; @Override public Screen getScreen() &#123; return new Screen.Screen5();//小屏手机 &#125;&#125; 以上例子可以看出，抽象工厂可以解决一系列的产品生产的需求，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展； 总结 对于简单工厂和工厂方法来说，两者的使用方式实际是一样的，对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式。毕竟效果都一样，何必要用一个写起来更麻烦的方法呢。 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产。","categories":[],"tags":[]},{"title":"建造者模式（Builder Patttern）","slug":"建造者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:47:06.097Z","comments":true,"path":"2021/05/22/建造者模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式（Builder Patttern）在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。这时就需要建造者模式来解决。 1. 定义指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 2. 优缺点优点 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 缺点 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 3. 原理主要角色 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：也叫导演类，它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 结构图 实现步骤 创建抽象建造者定义造房步骤 创建工人具体实现造房步骤 创建承包商指挥工人施工 验收，检查是否建造完成 4. 代码实现产品类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.yang.builder;/** * @program: Product * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:41 */public class Product &#123; private String buildA; private String buildB; private String buildC; private String buildD; public String getBuildA() &#123; return buildA; &#125; public void setBuildA(String buildA) &#123; this.buildA = buildA; &#125; public String getBuildB() &#123; return buildB; &#125; public void setBuildB(String buildB) &#123; this.buildB = buildB; &#125; public String getBuildC() &#123; return buildC; &#125; public void setBuildC(String buildC) &#123; this.buildC = buildC; &#125; public String getBuildD() &#123; return buildD; &#125; public void setBuildD(String buildD) &#123; this.buildD = buildD; &#125; @Override public String toString() &#123; return &quot;Product&#123;&quot; + &quot;buildA=&#x27;&quot; + buildA + &#x27;\\&#x27;&#x27; + &quot;, buildB=&#x27;&quot; + buildB + &#x27;\\&#x27;&#x27; + &quot;, buildC=&#x27;&quot; + buildC + &#x27;\\&#x27;&#x27; + &quot;, buildD=&#x27;&quot; + buildD + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 建造类123456789101112131415161718package com.yang.builder;/** * @program: Build * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:43 */public abstract class Build &#123; public abstract Build setBuildA(); public abstract Build setBuildB(); public abstract Build setBuildC(); public abstract Build setBuildD(); public abstract Product getProduct();&#125; 具体建造者类1234567891011121314151617181920212223242526272829303132333435363738394041package com.yang.builder;/** * @program: Worker * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:45 */public class Worker extends Build &#123; private Product product; public Worker() &#123; product = new Product(); &#125; public Build setBuildA() &#123; product.setBuildA(&quot;地基&quot;); return this; &#125; public Build setBuildB() &#123; product.setBuildB(&quot;钢金&quot;); return this; &#125; public Build setBuildC() &#123; product.setBuildC(&quot;水电&quot;); return this; &#125; public Build setBuildD() &#123; product.setBuildD(&quot;粉刷&quot;); return this; &#125; public Product getProduct() &#123; return product; &#125;&#125; 导演类1234567891011121314151617package com.yang.builder;/** * @program: Derict * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:48 */public class Derict &#123; public Product create(Build build)&#123; build.setBuildA().setBuildB().setBuildC().setBuildD(); return build.getProduct(); &#125;&#125; 客户类1234567891011121314151617package com.yang.builder;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 15:50 */public class MyDemo &#123; public static void main(String[] args) &#123; Derict derict = new Derict(); Product product = derict.create(new Worker()); System.out.println(product); &#125;&#125;","categories":[],"tags":[]},{"title":"静态代理模式（Static Proxy）","slug":"静态代理模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:47:34.641Z","comments":true,"path":"2021/05/22/静态代理模式/","link":"","permalink":"http://example.com/2021/05/22/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"静态代理模式（Static Proxy）1. 定义给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。防止直接访问目标对象给系统带来的不必要复杂性。 2. 优缺点优点 可以使真是角色的操作更加纯粹，不用去关心一些公共业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点 一个真是角色会产生一个代理角色，代码量翻倍，开发效率低！ 实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。 3. 原理角色 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 结构图 实现步骤 创建抽象对象接口（Subject） 创建真实对象类（RealSubject） 创建代理对象类（Proxy） 客户端调用 4. 代码实现比如，现在我要租一个房子，但是我又不想自己去找房东，也不想自己去谈价钱，看房子这些破事儿，我就可以去找中介代理帮我做。 创建一个Rent接口12345package com.yang.proxy.demo1;public interface Rent &#123; public void rentRoom();&#125; 创建一个真实对象类1234567891011121314package com.yang.proxy.demo1;/** * @program: Client * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:52 */public class Client implements Rent &#123; public void rentRoom() &#123; System.out.println(&quot;我是客户，我要租房子&quot;); &#125;&#125; 创建代理对象类12345678910111213141516171819202122232425262728293031323334package com.yang.proxy.demo1;/** * @program: Proxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:53 */public class Proxy implements Rent &#123; private Client client; public Proxy() &#123; &#125; public Proxy(Client client) &#123; this.client = client; &#125; public void rentRoom() &#123; lookRoom(); client.rentRoom(); bargin(); &#125; public void bargin()&#123; System.out.println(&quot;我是中介，我在讲价&quot;); &#125; public void lookRoom()&#123; System.out.println(&quot;我是中介，我在看房&quot;); &#125;&#125; 调用12345678910111213141516package com.yang.proxy.demo1;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 16:54 */public class MyDemo &#123; public static void main(String[] args) &#123; Client client = new Client(); Proxy proxy = new Proxy(client); proxy.rentRoom(); &#125;&#125;","categories":[],"tags":[]},{"title":"动态代理（Dynamic Proxy）","slug":"动态代理","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:47:50.200Z","comments":true,"path":"2021/05/22/动态代理/","link":"","permalink":"http://example.com/2021/05/22/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"动态代理（Dynamic Proxy）1.定义原理和静态代理相同，只是为了解决静态代理的缺点。详情请点静态代理 2. 优缺点优点除了静态代理的优点外，还解决了静态代理的短板，可以动态生成代理类，大大减少了代码量。 缺点由于用的是反射的原理，性能相对较低。 3. 步骤角色： 接口类 实现类：被代理的类 代理类：必须实现InvocationHandler接口 4. 代码为了更加形象地理解JDK动态代理的使用流程，举个栗子。 今天，小黑要和王美丽去相亲，但是由于王美丽和小黑是第一次见面，小黑不好意思直接去找她的家人邀请她去约会和看电影。先看代码： Girl接口和王美丽的实体类： 12345678910111213package com.yang.proxy.demo2;/** * @program: Girl * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:47 */public interface Girl &#123; public void date(); public void watchMovie();&#125; 12345678910111213141516171819package com.yang.proxy.demo2;/** * @program: WangMeiLi * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:46 */public class WangMeiLi implements Girl &#123; public void date() &#123; System.out.println(&quot;王美丽：长得好看就行&quot;); &#125; public void watchMovie() &#123; System.out.println(&quot;王美丽：和你看电影很开心&quot;); &#125;&#125; 代理类： 123456789101112131415161718192021222324252627282930313233343536373839package com.yang.proxy.demo2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @program: MyProxy * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:55 */public class MyProxy implements InvocationHandler &#123; private Object target; public MyProxy(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Dad(); Object invoke = method.invoke(target, args); Mom(); return invoke; &#125; public Object getInstance()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; public void Dad()&#123; System.out.println(&quot;对你好不好?&quot;); &#125; public void Mom()&#123; System.out.println(&quot;有房吗？有车吗？&quot;); &#125;&#125; 小黑通过王美丽的家人去约她，王美丽的动作很单纯，值管看电影和看人家小黑好不好看。但是她的家人（代理类）可不放心，她的家人还要在invoke()方法里进行方法增强，比图说，她爸爸要看小黑对她好不好，她妈妈要看小黑有没有房和车。增强后才放心地用getInstance()方法让女儿去和小黑约会。 现在使用测试类进行测试： 123456789101112131415161718192021package com.yang.proxy.demo2;/** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */public class Demo &#123; public static void main(String[] args) &#123; WangMeiLi wangMeiLi = new WangMeiLi(); XiaoHei xiaoHei = new XiaoHei(); MyProxy families = new MyProxy(wangMeiLi); Girl wmother = (Girl) families.getInstance(); wmother.date(); wmother.watchMovie(); &#125;&#125; 结果如下： 对你好不好?王美丽：长得好看就行有房吗？有车吗？对你好不好?王美丽：和你看电影很开心有房吗？有车吗？ 此时，基础的代理功能已经达到了，但是还没有测试动态这个特点。因此我们现在创建一个Boy接口和小黑的类。 123456package com.yang.proxy.demo2;public interface Boy &#123; public void date(); public void watchMovie();&#125; 123456789101112131415161718package com.yang.proxy.demo2;/** * @program: XiaoHei * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 20:39 */public class XiaoHei implements Boy &#123; public void date() &#123; System.out.println(&quot;好看就行&quot;); &#125; public void watchMovie() &#123; System.out.println(&quot;电影不好看&quot;); &#125;&#125; 现在我们没有为小黑做任何的代理类，现在我们用这个动态代理类进行测试： 1234567891011121314151617181920package com.yang.proxy.demo2;/** * @program: Demo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-20 19:57 */public class Demo &#123; public static void main(String[] args) &#123; XiaoHei xiaoHei = new XiaoHei(); MyProxy heiFamilies = new MyProxy(xiaoHei); Boy hMother = (Boy) heiFamilies.getInstance(); hMother.date(); hMother.watchMovie(); &#125;&#125; 结果如下： 对你好不好?小黑:好看就行有房吗？有车吗？对你好不好?小黑:电影不好看有房吗？有车吗？ 可见，测试成功！","categories":[],"tags":[]},{"title":"模板模式（Template Pattern）","slug":"模板模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:48:24.665Z","comments":true,"path":"2021/05/22/模板模式/","link":"","permalink":"http://example.com/2021/05/22/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板模式（Template Pattern）完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。这就是模板模式。 1. 定义定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 2. 优缺点优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 3. 原理角色 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中申明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 结构图 4. 代码实现老规矩，举个栗子。迎接客人，而这个迎接客人的流程是一样的，都是visit、talk、bye。但是根据客人身份的不同，实现的方式也不同，这里设定的是两种客人，一种是儿子带女朋友回家，一个是女儿带男朋友回家。 抽象类： 123456789101112131415161718192021/** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */public abstract class Welcome &#123; public abstract void visit(); public abstract void talk(); public abstract void bye(); public void run()&#123; visit(); talk(); bye(); &#125;&#125; 迎接儿子女朋友的实现类： 12345678910111213141516171819202122package com.yang.template;/** * @program: LoverOfSon * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:51 */public class LoverOfSon extends Welcome &#123; public void visit() &#123; System.out.println(&quot;来就来嘛还带这么多东西&quot;); &#125; public void talk() &#123; System.out.println(&quot;这姑娘真不错&quot;); &#125; public void bye() &#123; System.out.println(&quot;20w彩礼，你看看够不够，不够我们再加&quot;); &#125;&#125; 迎接女儿男朋友的实现类： 12345678910111213141516171819202122package com.yang.template;/** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(&quot;除了华子，送别的烟我不抽，拉嗓子&quot;); &#125; public void talk() &#123; System.out.println(&quot;有车吗？有房吗？有什么学位？&quot;); &#125; public void bye() &#123; System.out.println(&quot;没50w彩礼别想娶我家姑娘&quot;); &#125;&#125; 测试类： 1234567891011121314151617181920package com.yang.template;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:56 */public class MyDemo &#123; public static void main(String[] args) &#123; Welcome loverOfSon = new LoverOfSon(); loverOfSon.run(); System.out.println(); Welcome loverOfDaughter = new LoverOfDaughter(); loverOfDaughter.run(); &#125;&#125; 运行结果 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？没50w彩礼别想娶我家姑娘 可见这个模式已经实现。但是此时还有一个新问题，如果说客人来了，还得吃饭，老头还得喝点。那么就需要在Welcome流程里加一个喝酒类，但是也不行，如果是儿子带女朋友回来的话，让人一姑娘喝酒也不合适。这时我们要解决的问题就是，通过子类的操作来实现，对父类流程的调控。因此我们用了一个钩子方法来解决这个问题。下面我们对上面的代码进行改造。 Welcaome类： 1234567891011121314151617181920212223242526272829303132package com.yang.template;/** * @program: Welcome * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:49 */public abstract class Welcome &#123; protected boolean isDrink()&#123; return false; &#125; protected abstract void visit(); protected abstract void talk(); protected abstract void bye(); protected void Drink()&#123; System.out.println(&quot;哈啤酒~~~&quot;); &#125; public void run()&#123; visit(); talk(); if (isDrink())&#123; Drink(); &#125; bye(); &#125;&#125; LoverOfDaughter类： 1234567891011121314151617181920212223242526272829303132package com.yang.template;/** * @program: LoverOfDaughter * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 14:53 */public class LoverOfDaughter extends Welcome &#123; public void visit() &#123; System.out.println(&quot;除了华子，送别的烟我不抽，拉嗓子&quot;); &#125; public void talk() &#123; System.out.println(&quot;有车吗？有房吗？有什么学位？&quot;); &#125; @Override protected boolean isDrink() &#123; return true; &#125; @Override protected void Drink() &#123; System.out.println(&quot;喝白的&quot;); &#125; public void bye() &#123; System.out.println(&quot;没50w彩礼别想娶我家姑娘&quot;); &#125;&#125; 其他类保持原样，运行之后的效果如下： 来就来嘛还带这么多东西这姑娘真不错20w彩礼，你看看够不够，不够我们再加 除了华子，送别的烟我不抽，拉嗓子有车吗？有房吗？有什么学位？喝白的没50w彩礼别想娶我家姑娘 我们以上的问题已经解决，在这次改进中，我给isDrick()方法了初始值，就是不喝，也给了Drink()方法了初始值。这样子类就可以根据需要进行选择重写或者不重写。 这就是我们的模板模式，看完之后可能第一感觉就是，非常熟悉。是的，我们的编码过程中，经常使用，但是不知道它的名字而已。设计模式仅仅是一个设计过程中的技巧和模式。在实际开发中，知不知道他的名字无所谓，到了使用的时候，自然就用出来了。这就是传说中的，无招胜有招。","categories":[],"tags":[]},{"title":"观察者模式（Observer Pattern）","slug":"观察者模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:48:52.675Z","comments":true,"path":"2021/05/22/观察者模式/","link":"","permalink":"http://example.com/2021/05/22/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式（Observer Pattern）在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。 1. 定义指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 2. 优缺点优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 3. 实现角色 抽象对象（IObject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体对象（Concrete Object）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 模式图 4. 代码抽象对象类： 123456789101112131415161718192021222324252627282930package com.yang.observe;import java.util.ArrayList;import java.util.List;/** * @program: IObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:02 */public abstract class IObject &#123; protected List&lt;IObserver&gt; list=new ArrayList&lt;IObserver&gt;(); //增加观察者方法 public void add(IObserver observer) &#123; list.add(observer); &#125; //删除观察者方法 public void remove(IObserver observer) &#123; list.remove(observer); &#125; //通知观察者方法 public abstract void notifyObserver();&#125; 具体对象类： 123456789101112131415161718package com.yang.observe;/** * @program: ConcreteObject * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:05 */public class ConcreteObject extends IObject &#123; public void notifyObserver() &#123; System.out.println(&quot;目标角色发生了变化&quot;); for (IObserver observer : super.list) &#123; observer.response(&quot;ConcreteObject发生变化&quot;); &#125; &#125;&#125; 观察者接口： 123456789101112package com.yang.observe;/** * @program: IObserver * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */public interface IObserver &#123; public void response(String msg);&#125; 具体观察者1 123456789101112131415package com.yang.observe;/** * @program: Observer * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:03 */public class Observer1 implements IObserver&#123; public void response(String msg) &#123; System.out.println(&quot;Observer01知道了[&quot; + msg + &quot;]&quot; ); &#125;&#125; 具体观察者2： 123456789101112131415package com.yang.observe;/** * @program: Observer2 * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:10 */public class Observer2 implements IObserver&#123; public void response(String msg) &#123; System.out.println(&quot;Observer02知道了[&quot; + msg + &quot;]&quot; ); &#125;&#125; 测试类： 1234567891011121314151617181920package com.yang.observe;/** * @program: MyDemo * @description: TODO * @author: yangxun199807@163.com * @create: 2020-07-21 17:11 */public class MyDemo &#123; public static void main(String[] args) &#123; Observer1 observer1 = new Observer1(); Observer2 observer2 = new Observer2(); ConcreteObject concreteObject = new ConcreteObject(); concreteObject.add(observer1); concreteObject.add(observer2); concreteObject.notifyObserver(); &#125;&#125; 运行结果： 目标角色发生了变化Observer01知道了[ConcreteObject发生变化]Observer02知道了[ConcreteObject发生变化]","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-22T04:48:48.914Z","updated":"2021-05-22T04:48:48.914Z","comments":true,"path":"2021/05/22/hello-world/","link":"","permalink":"http://example.com/2021/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}