{"meta":{"title":"LittleY'Blog","subtitle":"","description":"","author":"LittleY","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"单例模式","slug":"单例模式","date":"2021-05-22T06:42:30.000Z","updated":"2021-05-22T06:42:49.254Z","comments":true,"path":"2021/05/22/单例模式/","link":"","permalink":"http://example.com/2021/05/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式在有些开发场景中，没有必要有多个实例存在，以节省资源。比如说 PropertiyMgr 工具类 饿汉式实现代码如下： 12345678910111213141516171819public class Mgr01 &#123; private static final Mgr01 INSTANCE = new Mgr01(); private Mgr01() &#123;&#125;; public static Mgr01 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr01 m1 = Mgr01.getInstance(); Mgr01 m2 = Mgr01.getInstance(); System.out.println(m1 == m2); &#125;&#125; 还有一种写法，和上面的写法效果一模一样： 12345678910111213141516171819202122public class Mgr02 &#123; private static final Mgr02 INSTANCE; static &#123; INSTANCE = new Mgr02(); &#125; private Mgr02() &#123;&#125;; public static Mgr02 getInstance() &#123; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125; public static void main(String[] args) &#123; Mgr02 m1 = Mgr02.getInstance(); Mgr02 m2 = Mgr02.getInstance(); System.out.println(m1 == m2); &#125;&#125; 优点：类加载到内存后，就实例化一个单例，JVM 保证线程安全简单实用，推荐使用！ 缺点：不管用到与否，类装载时就完成实例化。如果用不上它的话，装载它会造成资源浪费。 由此我们有了另一个解决方案，那就是懒汉式： 懒汉式（Lazy Loading）第一种写法实现代码如下： 12345678910111213141516171819202122public class Mgr03 &#123; private static Mgr03 INSTANCE; private Mgr03() &#123; &#125; public static Mgr03 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr03(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 由上面代码可知，使用懒汉式之后，达到了按需初始化的目的。但是随之而来的是更严重的问题，那就是它的线程不安全问题。 就是说，两个线程如果接近同时进入 INSTANCE == null 的判断语句时，两个都会进入里面的代码块进行new对象。可知此时两个线程拿到的实例就不是同一个实例。这就是线程不安全问题。可以用以下测试代码对其进行测试： 1234567public static void main(String[] args) &#123; for(int i=0; i&lt;100; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Mgr04.getInstance().hashCode()); &#125;).start(); &#125;&#125; 为了解决线程不安全的问题，我们又进行了以下优化： 第二种写法代码如下： 12345678910111213141516171819202122public class Mgr04 &#123; private static Mgr04 INSTANCE; private Mgr04() &#123; &#125; public static synchronized Mgr04 getInstance() &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr04(); &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 我们对实例方法进行了加锁处理，保证了线程安全的问题。但是，不难想象，如果有大量的线程访问的话，那么它的效率会大幅下降。 我们再做一下优化： 123456789101112131415161718192021222324public class Mgr05 &#123; private static Mgr05 INSTANCE; private Mgr05() &#123; &#125; public static Mgr05 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Mgr05.class) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr05(); &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次我们把锁加在了实例方法里面的Mgr05.class上，妄图通过减小同步代码块的方式提高效率，测试后，不可行。 原因是，虽然对Mgr05.class进行了加锁，但是如果两个线程同时进入INSTANCE==null代码块里面，它依然会new出两个不同的实例。 现在可知，问题就处在了INSTANCE == null判断语句这块儿，那么我们针对这块儿进行优化。 第三种写法123456789101112131415161718192021222324252627public class Mgr06 &#123; private static Mgr06 INSTANCE; //JIT private Mgr06() &#123; &#125; public static Mgr06 getInstance() &#123; if (INSTANCE == null) &#123; //双重检查 synchronized (Mgr06.class) &#123; if(INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Mgr06(); &#125; &#125; &#125; return INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这次优化，我们针对的就是判断实例是否为空这个点，进行了双层检查，即使两个同时进入了第一层判断，一个拿到锁之后，先实例化了一个对象，第二个再进去之后，还需要第二只判断，如果已经有了实例，那么就直接跳出，不再new新的实例。 这时可能会有个疑问，那么外层的检查还有必要存在吗？答案是当然需要，如果没有了外层的判断，每个线程都要加锁上锁，不得把JVM累死，下可能自然就变差了。 静态内部类方式代码如下： 12345678910111213141516public class Mgr07 &#123; private Mgr07() &#123; &#125; private volatile static class Mgr07Holder &#123; private final static Mgr07 INSTANCE = new Mgr07(); &#125; public static Mgr07 getInstance() &#123; return Mgr07Holder.INSTANCE; &#125; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125; 这个方法算是目前来说比较完美的一种写法。JVM保证单例，加载外部类时不会加载内部类，这样可以即可以实现懒加载，还能保证线程安全。 注意使用volatile修饰单例对象，目的是保证多线程环境下的线程安全。 枚举类方法代码如下： 1public enum Mgr08 &#123; INSTANCE; public void m() &#123;&#125;&#125; 这是《Java Effective》这本书中的一种写法，写法简单，还能保证线程同步问题，还可以防止反序列化(通俗点说就是防止反射对其造成的破坏)。中功能上来说是所有单例模式写法中最完美的。但是个人不推荐这种写法，比较别扭，不够优雅。 设计模式是一种生产技巧和模式，没有必要像孔乙己一样研究茴字有几种写法，以实际开发的场景的选择不同的写法。","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2021-05-22T06:11:32.000Z","updated":"2021-05-22T06:11:55.208Z","comments":true,"path":"2021/05/22/test/","link":"","permalink":"http://example.com/2021/05/22/test/","excerpt":"","text":"嘿嘿嘿嘿","categories":[],"tags":[{"name":"测试 图片","slug":"测试-图片","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95-%E5%9B%BE%E7%89%87/"}]},{"title":"My New Post","slug":"My-New-Post","date":"2021-05-22T05:22:59.000Z","updated":"2021-05-22T05:51:40.724Z","comments":true,"path":"2021/05/22/My-New-Post/","link":"","permalink":"http://example.com/2021/05/22/My-New-Post/","excerpt":"","text":"测试测试这是内容","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-22T04:48:48.914Z","updated":"2021-05-22T04:48:48.914Z","comments":true,"path":"2021/05/22/hello-world/","link":"","permalink":"http://example.com/2021/05/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"测试 图片","slug":"测试-图片","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95-%E5%9B%BE%E7%89%87/"}]}